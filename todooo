/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd.c                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 17:57:28 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/16 16:15:44 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtins.h"

static char	*cd_build_path(t_exec *exec, char **arg)
{
	char	*cwd;
	char	*tmp;
	char	*path;

	if (!arg[1] || arg[1][0] == '~')
		return (ft_strdup(dict_get(exec->env, "HOME")));
	if (arg[1][0] == '/')
		return (ft_strdup(arg[1]));
	cwd = dict_get(exec->env, "PWD");
	tmp = ft_strjoin(cwd, "/");
	path = ft_strjoin(tmp, arg[1]);
	free(tmp);
	return (path);
}

static int	change_to_oldpwd(t_exec *exec)
{
	const char	*old_dir = dict_get(exec->env, "OLDPWD");
	char		current_wd[PATH_MAX];

	if (!old_dir)
		return (perror("cd: OLDPWD not set"), 1);
	if (chdir(old_dir) != 0)
		return (perror("cd"), 1);
	if (!getcwd(current_wd, PATH_MAX))
		return (perror("cd: getcwd"), 1);
	dict_insert(&exec->env, dict_create_entry(ft_strdup("OLDPWD"),
			ft_strdup(dict_get(exec->env, "PWD"))));
	dict_insert(&exec->env, dict_create_entry(ft_strdup("PWD"),
			ft_strdup(current_wd)));
	return (0);
}

static int	change_directory(t_exec *exec, const char *path)
{
	char	old_cwd[PATH_MAX];
	char	new_cwd[PATH_MAX];

	ft_strlcpy(old_cwd, dict_get(exec->env, "PWD"), PATH_MAX);
	if (chdir(path) != 0)
		return (perror("cd"), 1);
	if (!getcwd(new_cwd, PATH_MAX))
		return (perror("cd: getcwd"), 1);
	dict_insert(&exec->env, dict_create_entry(ft_strdup("OLDPWD"),
			ft_strdup(old_cwd)));
	dict_insert(&exec->env, dict_create_entry(ft_strdup("PWD"),
			ft_strdup(new_cwd)));
	return (0);
}

int	cd(t_exec *exec, char **arg)
{
	int		ret;
	char	*path;

	if (arg[1] && arg[2])
		return (ft_putendl_fd("cd: too many arguments", 2), 1);
	if (arg[1] && arg[1][0] == '-' && arg[1][1] == '\0')
		return (change_to_oldpwd(exec));
	path = cd_build_path(exec, arg);
	if (!path)
		return (ft_putendl_fd("cd: HOME not set", 2), 1);
	ret = change_directory(exec, path);
	free(path);
	return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   echo.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 17:57:52 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/15 15:46:43 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtins.h"

int	process_flags(char **arguments, int *i)
{
	int		new_line;
	size_t	j;

	new_line = 1;
	while (arguments[*i] && arguments[*i][0] == '-' && arguments[*i][1] == 'n')
	{
		j = 1;
		while (arguments[*i][j] == 'n')
			j++;
		if (arguments[*i][j] != '\0')
			break ;
		new_line = 0;
		(*i)++;
	}
	return (new_line);
}

void	echo(char **arguments)
{
	int		i;
	int		new_line;

	i = 0;
	new_line = process_flags(arguments, &i);
	arguments++;
	while (arguments[i])
	{
		ft_printf("%s", arguments[i]);
		if (arguments[i + 1])
			ft_printf(" ");
		i++;
	}
	if (new_line)
		write(1, "\n", 1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 17:58:02 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/17 10:48:08 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtins.h"

static int	is_exportable_var(t_dictionary *dic, char *key)
{
	unsigned int	index;
	unsigned int	counter;

	if (key == NULL)
		return (0);
	index = dict_hash(key) % dic->capacity;
	counter = 0;
	while (counter < dic->capacity - 1)
	{
		if (dic->entries[index] && !ft_strcmp(dic->entries[index]->key, key))
			return (dic->entries[index]->export);
		index++;
		if (index == dic->capacity - 1)
			index = 0;
		counter++;
	}
	return (0);
}

int	ft_env(char **args, t_exec *exec)
{
	char	**env_keys;
	char	**tmp;

	env_keys = dict_get_keys(exec->env);
	tmp = env_keys;
	if (args[0] && args[1] == NULL)
	{
		while (*env_keys != NULL)
		{
			if (is_exportable_var(exec->env, *env_keys))
				ft_printf("%s=%s\n", *env_keys, dict_get(exec->env, *env_keys));
			env_keys++;
		}
	}
	else
	{
		ft_putstr_fd("minishell: env: too much arguments\n", 2);
		ft_free_array(tmp);
		return (1);
	}
	ft_free_array(tmp);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 17:58:16 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/20 15:58:18 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtins.h"

int	is_numeric(const char *str)
{
	int	i;

	i = 0;
	if (str[i] == '-' || str[i] == '+')
		i++;
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}

int	ft_exit(char **args)
{
	int	status;

	rl_clear_history();
	if (!args[1])
		(ft_free_array(args), exit(0));
	if (!is_numeric(args[1]))
	{
		ft_printf("exit\n");
		ft_printf("exit: %s: numeric argument required\n", args[1]);
		exit(2);
	}
	if (args[2])
	{
		ft_printf("exit: too many arguments\n");
		return (1);
	}
	status = ft_atoi(args[1]);
	(ft_free_array(args), exit (status % 256));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 17:58:23 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/15 16:43:07 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"
#include "builtins.h"

void	export_error(char *name)
{
	ft_printf("minishell: export: `%s': not a valid identifier\n", name);
}

int	print_exported_vars(t_exec *exec)
{
	char	**env_keys;
	char	*value_for_printing;
	int		i;

	i = -1;
	env_keys = dict_get_keys(exec->env);
	if (!env_keys)
		return (1);
	sort_strings(env_keys, exec->env->capacity);
	while (env_keys[++i])
	{
		value_for_printing = dict_get(exec->env, env_keys[i]);
		ft_printf("declare -x %s", env_keys[i]);
		if (value_for_printing != NULL)
			ft_printf("=\"%s\"", value_for_printing);
		ft_printf("\n");
	}
	return (0);
}

int	process_argument(char *argument, t_exec *exec)
{
	t_dic_entry	*entry;
	char		**var;
	char		*value;

	var = ft_split(argument, '=');
	if (!var)
		return (1);
	if (is_valid_name(var[0]))
	{
		if (var[1] == NULL && ft_strchr(argument, '='))
			value = "";
		else
			value = var[1];
		entry = dict_create_entry(ft_strdup(var[0]), ft_strdup(value));
		if (ft_strchr(argument, '='))
			entry->export = 1;
		dict_insert(&exec->env, entry);
	}
	else
		return (export_error(argument), ft_free_array(var), 1);
	ft_free_array(var);
	return (0);
}

int	export(t_exec *exec, char **arguments)
{
	int	status;
	int	i;

	status = 0;
	if (arguments[1] == NULL)
	{
		print_exported_vars(exec);
		return (0);
	}
	i = 1;
	while (arguments[i])
	{
		if (process_argument(arguments[i], exec))
			status = 1;
		i++;
	}
	return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 16:41:21 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/15 16:42:21 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtins.h"

int	legal_variable_starter(int c)
{
	return (ft_isalpha(c) || c == '_');
}

int	legal_variable_char(int c)
{
	return (ft_isalnum(c) || c == '_');
}

int	is_valid_name(char *name)
{
	if (!name)
		return (0);
	if (!legal_variable_starter(*name))
		return (0);
	while (*name)
	{
		if (!legal_variable_char(*name))
			return (0);
		name++;
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pwd.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 17:58:33 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/16 17:44:40 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtins.h"
#include <unistd.h>

int	ft_pwd(void)
{
	char	buffer[1024];

	if (getcwd(buffer, sizeof(buffer)))
		ft_printf("%s\n", buffer);
	else
		perror("Error_pwd: too many arguments");
	return (0);
}

int	pwd2(void)
{
	if (ft_pwd() != 0)
	{
		ft_printf("error");
		return (1);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   unset.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 17:58:43 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/18 16:06:59 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "builtins.h"

void	remove_env_var(t_exec *exec, char *var_name)
{
	int		j;
	char	**env;

	env = dict_envp(exec->env);
	j = 0;
	while (env[j])
	{
		if (!ft_strncmp(env[j], var_name, ft_strlen(var_name))
			&& env[j][ft_strlen(var_name)] == '=')
		{
			dict_delete_key(exec->env, var_name);
			break ;
		}
		j++;
	}
	ft_free_array(env);
}

int	unset(t_exec *exec, char **arg)
{
	int	i;

	i = 1;
	if (!arg[1])
		return (0);
	if (!exec->env || exec->env->entries == NULL)
		return (0);
	while (arg[i])
	{
		if (!is_valid_name(arg[i]))
			export_error(arg[i]);
		else
			remove_env_var(exec, arg[i]);
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   dictionary2.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/10 12:09:28 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/15 16:17:50 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "dictionary.h"
#include <stdio.h>

char	*dict_get(t_dictionary *dic, char *key)
{
	unsigned int	index;
	unsigned int	counter;

	if (key == NULL)
		return (NULL);
	index = dict_hash(key) % dic->capacity;
	counter = 0;
	while (counter < dic->capacity - 1)
	{
		if (dic->entries[index] && !ft_strcmp(dic->entries[index]->key, key))
			return (dic->entries[index]->value);
		index++;
		if (index == dic->capacity - 1)
			index = 0;
		counter++;
	}
	return (NULL);
}

void	dict_delete(t_dictionary *dic)
{
	unsigned int	i;

	i = 0;
	while (i < dic->capacity)
	{
		if (dic->entries[i] != NULL)
		{
			free(dic->entries[i]->key);
			free(dic->entries[i]->value);
			free(dic->entries[i]);
		}
		i++;
	}
	free(dic->entries);
	free(dic);
}

t_dic_entry	*dict_create_entry(char *key, char *value)
{
	t_dic_entry	*ret_entry;

	ret_entry = ft_calloc(1, sizeof(t_dic_entry));
	if (!ret_entry)
		return (NULL);
	ret_entry->key = key;
	ret_entry->value = value;
	return (ret_entry);
}

void	dict_delete_key(t_dictionary *dict, char *key)
{
	unsigned int	index;
	unsigned int	counter;

	if (key == NULL)
		write(1, "", 0);
	index = dict_hash(key) % dict->capacity;
	counter = 0;
	while (counter < dict->capacity - 1)
	{
		if (dict->entries[index] && !ft_strcmp(dict->entries[index]->key, key))
		{
			if (dict->entries[index]->key)
				free(dict->entries[index]->key);
			if (dict->entries[index]->value)
				free(dict->entries[index]->value);
			free(dict->entries[index]);
			dict->entries[index] = NULL;
			return ;
		}
		index++;
		if (index == dict->capacity - 1)
			index = 0;
		counter++;
	}
}

char	**dict_get_keys(t_dictionary *dict)
{
	unsigned int	counter;
	char			**ret;
	char			**tmp;

	ret = malloc((dict->capacity + 1) * sizeof(char *));
	if (!ret)
		return (NULL);
	tmp = ret;
	counter = 0;
	while (counter < dict->capacity - 1)
	{
		if (dict->entries[counter])
		{
			*tmp = dict->entries[counter]->key;
			tmp++;
		}
		counter++;
	}
	*tmp = NULL;
	return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   dictionary.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/10 12:09:15 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/15 17:51:57 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "dictionary.h"

t_dictionary	*dict_init(int capacity)
{
	t_dictionary	*dic;
	t_dic_entry		**entries;
	int				dic_capacity;

	dic_capacity = 0;
	dic = (t_dictionary *)malloc(sizeof(t_dictionary));
	if (!dic)
		return (NULL);
	if (capacity <= 0)
		dic_capacity = INITIAL_CAPACITY;
	else
		dic_capacity = capacity;
	dic->capacity = dic_capacity;
	dic->n_elements = 0;
	entries = (t_dic_entry **)malloc(dic_capacity * sizeof(t_dic_entry *));
	if (!entries)
		return (free(dic), NULL);
	dic->entries = entries;
	while (dic_capacity--)
		dic->entries[dic_capacity] = NULL;
	return (dic);
}

unsigned int	dict_hash(char *key)
{
	unsigned int	hash;
	int				i;
	int				length;

	hash = 2166136261u;
	i = 0;
	length = ft_strlen(key);
	while (i < length)
	{
		hash ^= (uint8_t)key[i];
		hash *= 16777619;
		i++;
	}
	return (hash);
}

static void	map_old_values(t_dictionary *old_dic, t_dictionary *new_dic)
{
	unsigned int	i;
	unsigned int	new_index;
	unsigned int	new_capacity;

	i = 0;
	new_capacity = new_dic->capacity;
	while (i < old_dic->capacity)
	{
		if (old_dic->entries[i] != NULL)
		{
			new_index = dict_hash(old_dic->entries[i]->key) % new_capacity;
			while (new_dic->entries[new_index] != NULL)
			{
				new_index++;
				if (new_index == new_dic->capacity - 1)
					new_index = 0;
			}
			new_dic->entries[new_index] = old_dic->entries[i];
		}
		i++;
	}
}

int	dict_expand(t_dictionary **dic_pointer)
{
	int				new_capacity;
	t_dictionary	*old_dic;
	t_dictionary	*new_dic;

	old_dic = *dic_pointer;
	new_capacity = old_dic->capacity * 2;
	new_dic = dict_init(new_capacity);
	if (new_dic == NULL)
		return (0);
	map_old_values(old_dic, new_dic);
	free(old_dic->entries);
	free(old_dic);
	*dic_pointer = new_dic;
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   dictionary_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:52:34 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/15 17:53:32 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "dictionary.h"

void	insert_or_update_entry(t_dictionary *dic, t_dic_entry *entry,
		unsigned int index)
{
	while (dic->entries[index] != NULL)
	{
		if (!ft_strcmp(dic->entries[index]->key, entry->key))
		{
			free(dic->entries[index]->value);
			dic->entries[index]->value = entry->value;
			free(entry->key);
			free(entry);
			return ;
		}
		index++;
		if (index == dic->capacity - 1)
			index = 0;
	}
	dic->entries[index] = entry;
	dic->n_elements++;
}

void	dict_insert(t_dictionary **dic_p, t_dic_entry *entry)
{
	unsigned int	hash_entry;
	unsigned int	index;
	t_dictionary	*dic;

	if (entry->key == NULL)
		return ;
	dic = *dic_p;
	if (dic->n_elements > (dic->capacity / 2))
	{
		if (!dict_expand(dic_p))
			return (dict_delete(dic));
		dic = *dic_p;
	}
	hash_entry = dict_hash(entry->key);
	index = hash_entry % dic->capacity;
	insert_or_update_entry(dic, entry, index);
	*dic_p = dic;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   dynamic_array.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 18:06:42 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/15 18:07:43 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "dynamic_array.h"

void	free_darray(t_darray *darray)
{
	free(darray->darray);
	free(darray);
}

t_darray	*alloc_darray(size_t len, size_t size)
{
	t_darray	*ret_darray;

	ret_darray = (t_darray *)ft_calloc(1, sizeof(t_darray));
	if (!ret_darray)
		return (NULL);
	ret_darray->darray = ft_calloc(len, sizeof(size));
	if (!ret_darray->darray)
		return (free(ret_darray), NULL);
	ret_darray->len = len;
	ret_darray->size = size;
	ret_darray->full_idx = 0;
	return (ret_darray);
}

int	resize_darray(t_darray **darray)
{
	size_t			i;
	void			*resz_darray;
	unsigned char	*str_darray;
	unsigned char	*str_resz_darray;

	i = 0;
	str_darray = (unsigned char *)(*darray)->darray;
	resz_darray = ft_calloc((2 * (*darray)->len), (*darray)->size);
	if (!resz_darray)
		return (0);
	str_resz_darray = (unsigned char *)resz_darray;
	while (i < (*darray)->len * (*darray)->size)
	{
		str_resz_darray[i] = str_darray[i];
		i++;
	}
	(*darray)->len *= 2;
	free((*darray)->darray);
	(*darray)->darray = resz_darray;
	return (1);
}

unsigned char	*r_darray(t_darray *darray, int idx)
{
	unsigned char	*str_darr;
	int				full_idx;
	size_t			bytes_size;

	full_idx = (int)darray->full_idx;
	if (!full_idx)
		return (darray->darray);
	if (-idx > full_idx || idx > full_idx - 1)
		return (NULL);
	if (idx >= 0)
		bytes_size = idx * darray->size;
	else
		bytes_size = (size_t)(full_idx + idx + 1) * darray->size;
	str_darr = &((unsigned char *)darray->darray)[bytes_size];
	return (str_darr);
}

int	append_darray(t_darray **darray, void *element)
{
	char	*str_darray;
	char	*str_element;
	size_t	i;

	i = 0;
	if ((*darray)->full_idx == (*darray)->len)
	{
		if (!resize_darray(darray))
			return (free_darray(*darray), 0);
	}
	str_darray = (char *)r_darray(*darray, -1);
	str_element = (char *)element;
	while (i < (*darray)->size)
	{
		str_darray[i] = str_element[i];
		i++;
	}
	(*darray)->full_idx++;
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_builtin_cmd.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42madrid.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 18:19:07 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/19 17:28:36by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "execution.h"
#include <errno.h>

char	*find_exec_in_path(char **path, char *exec)
{
	int		l_exec;
	int		l_path;
	char	pathname[1024];

	if (access(exec, X_OK) == 0)
		return (ft_strdup(exec));
	if (exec[0] == '/')
		return (NULL);
	l_exec = ft_strlen(exec);
	l_path = 0;
	if (path != NULL)
	{
		while (*path != NULL)
		{
			l_path = ft_strlen(*path);
			ft_strlcpy(pathname, *path, l_path + 2);
			if (pathname[l_path - 1] != '/')
				ft_strlcat(pathname, "/", l_path + 2);
			ft_strlcat(pathname, exec, l_exec + l_path + 2);
			if (access(pathname, X_OK) == 0)
				return (free(exec), ft_strdup(pathname));
			path++;
		}
	}
	return (exec);
}

static void	free_all(t_exec *exec_vars)
{
	close_cmd_fds(exec_vars->cmd);
	free_ast(exec_vars->mini->sequence);
	dict_delete(exec_vars->mini->env);
	free(exec_vars->mini->pids);
	close(exec_vars->mini->saved_std[0]);
	close(exec_vars->mini->saved_std[1]);
}

int	call_execve(t_exec *exec)
{
	char	**arguments;
	char	cmd_name[1024];
	char	**execve_args;
	char	**envp;
	char	**path;

	arguments = (char **)exec->cmd->cmd->darray;
	ft_bzero(cmd_name, 1024);
	ft_memcpy(cmd_name, arguments[0], ft_strlen(arguments[0]));
	path = ft_split(dict_get(exec->env, "PATH"), ':');
	arguments[0] = find_exec_in_path(path, arguments[0]);
	ft_free_array(path);
	execve_args = create_args(exec->cmd);
	envp = dict_envp(exec->env);
	execve(execve_args[0], execve_args, envp);
	ft_free_array(envp);
	ft_putstr_fd("minishell: ", 2);
	ft_putstr_fd(cmd_name, 2);
	close_cmd_fds(exec->cmd);
	free_ast(exec->mini->sequence);
	dict_delete(exec->mini->env);
	free(exec->mini->pids);
	if (access(execve_args[0], F_OK) == 0 && !ft_strncmp(execve_args[0], "./", 2))
		(ft_putstr_fd(": Permission denied\n", 2), ft_free_array(execve_args), exit(126));
	ft_free_array(execve_args);
	ft_putstr_fd(": command not found\n", 2);
	exit(127);
}

int	run_builtin(t_exec *exec)
{
	char	**arguments;
	int		status;

	status = 0;
	arguments = create_args(exec->cmd);
	if (!ft_strcmp(arguments[0], "echo"))
		echo(arguments);
	else if (!ft_strcmp(arguments[0], "export"))
		status = export(exec, arguments);
	else if (!ft_strcmp(arguments[0], "pwd"))
		pwd2();
	else if (!ft_strcmp(arguments[0], "env"))
		ft_env(arguments, exec);
	else if (!ft_strcmp(arguments[0], "exit"))
	{
		rl_clear_history(); 
		free_all(exec);
		status = ft_exit(arguments);
	}
	else if (!ft_strcmp(arguments[0], "unset"))
		unset(exec, arguments);
	else if (!ft_strcmp(arguments[0], "cd"))
		status = cd(exec, arguments);
	else
		ft_printf("minishell: command not found\n");
	free(arguments);
	return (status);
}

int	handle_child_process(t_exec *exec_vars)
{
	int	status;

	status = execute_io_redir(exec_vars);
	if (status)
		(free_all(exec_vars), exit(1));
	if (exec_vars->cmd->fds[0] != 0 && dup2(exec_vars->cmd->fds[0], 0) == -1)
		write(1, "Failed to redirect stdin.\n", 26);
	if (exec_vars->cmd->fds[1] != 1 && dup2(exec_vars->cmd->fds[1], 1) == -1)
		write(1, "Failed to redirect stdout.\n", 27);
	close_cmd_fds(exec_vars->cmd);
	if (status != 0)
		(free_all(exec_vars), exit(1));
	if (!status && is_builtin(exec_vars->cmd->cmd->darray))
		(free_all(exec_vars), exit(1));
	else if (!status && !is_builtin(exec_vars->cmd->cmd->darray))
		status = call_execve(exec_vars);
	free_all(exec_vars);
	exit(status);
}

int	execute_child(t_exec *exec_vars, t_cmd_pipe *sequence)
{
	int	ret;
	(void) sequence;

	ret = fork();
	if (ret == 0)
	{
		rl_clear_history();
		handle_child_process(exec_vars);
	}
	else
		close_cmd_fds(exec_vars->cmd);
	return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_io_redir.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 18:19:21 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/18 17:06:50by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "execution.h"

int	override_fd(t_exec *exec, t_io_redir *redir, int flags, int idx)
{
	int			fd;
	struct stat	file_stat;

	fd = open(redir->filename->text, flags, 0644);
	if (fd == -1)
	{
		perror(redir->filename->text);
		if (access(redir->filename->text, F_OK))
			return (1);
		if (stat(redir->filename->text, &file_stat) == -1)
			return (1);
		if (!(file_stat.st_mode & S_IWUSR) || !(file_stat.st_mode & S_IRUSR))
		{
			free_cmd(exec->cmd, 0);
			dict_delete(exec->env);
			return (1);
		}
		else
			return (1);
	}
	else
	{
		if (exec->cmd->fds[idx] > 2)
			close(exec->cmd->fds[idx]);
		exec->cmd->fds[idx] = fd;
	}
	return (0);
}

int	traverse_io_redir(t_io_redir *ix, t_exec *exec)
{
	int	status;

	status = 0;
	if (ix->op && ix->op->type != END && !ft_strncmp(ix->op->text, "<", 2))
	{
		status = override_fd(exec, ix, O_RDONLY, 0);
	}
	else if (ix->op && ix->op->type != END && !ft_strncmp(ix->op->text, "<<",
			2))
	{
		exec->cmd->fds[0] = open(ix->hd_name, O_RDONLY);
		if (exec->cmd->fds[0] == -1)
			return (1);
	}
	else if (ix->op && ix->op->type != END && !ft_strncmp(ix->op->text, ">", 2))
	{
		status = override_fd(exec, ix, O_WRONLY | O_CREAT | O_TRUNC, 1);
	}
	else if (ix->op && ix->op->type != END && !ft_strncmp(ix->op->text, ">>",
			2))
	{
		status = override_fd(exec, ix, O_WRONLY | O_CREAT | O_APPEND, 1);
	}
	return (status);
}

int	execute_io_redir(t_exec *exec)
{
	t_io_redir	*prefix;
	t_io_redir	*suffix;
	t_cmd 		*tmp_cmd;
	t_cmd 		*cmd;
	int			status;

	tmp_cmd = exec->cmd;
	cmd = exec->cmd;
	while (cmd)
	{
		prefix = exec->cmd->cmd_prefix;
		suffix = exec->cmd->cmd_suffix;
		status = 0;
		while (prefix)
		{
			status = traverse_io_redir(prefix, exec);
			if (status != 0)
			{
				exec->cmd = tmp_cmd;
				return (status);
			}
			prefix = prefix->next;
		}
		while (suffix)
		{
			status = traverse_io_redir(suffix, exec);
			if (status != 0)
			{
				exec->cmd = tmp_cmd;
				return (status);
			}
			suffix = suffix->next;
		}
		cmd = cmd->next;
	}
	exec->cmd = tmp_cmd;	
	return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 18:20:14 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/20 15:26:56 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "execution.h"

char	**create_args(t_cmd *cmd)
{
	char		**command_list;
	t_command	*ret_array;
	char		**tmp_array;
	char		*cmd_lst_dup;
	size_t		i;

	ret_array = alloc_darray(10, sizeof(char *));
	if (!ret_array)
		return (NULL);
	while (cmd)
	{
		i = -1;
		command_list = (char **)cmd->cmd->darray;
		while (command_list && command_list[++i])
		{
			cmd_lst_dup = ft_strdup(command_list[i]);
			if (!append_darray(&ret_array, &cmd_lst_dup))
				return (NULL);
		}
		cmd = cmd->next;
	}
	tmp_array = (char **)ret_array->darray;
	free(ret_array);
	return (tmp_array);
}

int	is_builtin(char **cmd_args)
{
	char	*cmd_name;

	cmd_name = cmd_args[0];
	if (!cmd_name)
		return (0);
	if (!ft_strcmp(cmd_name, "echo"))
		return (1);
	else if (!ft_strcmp(cmd_name, "export"))
		return (1);
	else if (!ft_strcmp(cmd_name, "pwd"))
		return (1);
	else if (!ft_strcmp(cmd_name, "env"))
		return (1);
	else if (!ft_strcmp(cmd_name, "unset"))
		return (1);
	else if (!ft_strcmp(cmd_name, "exit"))
		return (1);
	else if (!ft_strcmp(cmd_name, "cd"))
		return (1);
	return (0);
}

void	close_cmd_fds(t_cmd *cmd)
{
	if (cmd->fds[0] > 2)
		close(cmd->fds[0]);
	if (cmd->fds[1] > 2)
		close(cmd->fds[1]);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 18:20:37 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/20 15:52:00 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "execution.h"

void	handler_signint_child(int sig)
{
	(void)sig;
	write(STDOUT_FILENO, "\n", 1);
	rl_on_new_line();
	rl_replace_line("", 0);
	storage_signal(sig + 128, 1);
	close(0);
}

int	execute_sequence(t_cmd_pipe *sequence, t_dictionary *env, int n_cmd, t_minishell *mini)
{
	t_cmd_pipe *seq_start;
	t_exec	exec_vars;
	int		status;
	int		i;

	status = 0;
	mini->pids = ft_calloc(n_cmd, sizeof(pid_t));
	signal(SIGINT, handler_signint_child);
	i = 0;
	seq_start = sequence;
	while (sequence)
	{
		exec_vars = (t_exec){sequence->cmd, env, mini};
		mini->pids[i++] = execute_child(&exec_vars, seq_start);
		close_cmd_fds(sequence->cmd);
		sequence = sequence->next;
	}
	i = 0;
	while (i < n_cmd)
		waitpid(mini->pids[i++], &status, 0);
	free(mini->pids);
	return (WEXITSTATUS(status));
}

int	execute_builtin(t_exec *exec_vars)
{
	int	status;

	status = execute_io_redir(exec_vars);
	if (status != 0)
		return (status);
	if (exec_vars->cmd->fds[0] != 0 && dup2(exec_vars->cmd->fds[0], 0) == -1)
		write(1, "Siiiiiii\n", 10);
	if (exec_vars->cmd->fds[1] != 1 && dup2(exec_vars->cmd->fds[1], 1) == -1)
		write(1, "Siiiiiii\n", 10);
	status = run_builtin(exec_vars);
	close_cmd_fds(exec_vars->cmd);
	return (status);
}

int	executor(t_minishell *mini, t_cmd_pipe *sequence, t_dictionary *env)
{
	t_exec	exec_vars;
	int		status;
	int		n_cmd;

	status = 0;
	n_cmd = create_pipe_and_fds(sequence);
	expand_pipe_seq(sequence, env);
	mini->pids = NULL;
	if (n_cmd == 1 && is_builtin(sequence->cmd->cmd->darray))
	{
		exec_vars = (t_exec){sequence->cmd, env, mini};
		return (execute_builtin(&exec_vars));
	}
	else
		status = execute_sequence(sequence, env, n_cmd, mini);
	return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42madrid.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 18:38:07 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/19 18:59:25 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "execution.h"

int	create_pipe_and_fds(t_cmd_pipe *sequence)
{
	int	pipe_fd[2];
	int	old_fd;
	int	n_cmd;

	old_fd = 0;
	n_cmd = 1;
	while (sequence->next)
	{
		if (pipe(pipe_fd) == -1)
			write(1, "Error: Failed to create pipe\n", 29);
		sequence->cmd->fds[0] = old_fd;
		sequence->cmd->fds[1] = pipe_fd[1];
		old_fd = pipe_fd[0];
		n_cmd++;
		sequence = sequence->next;
	}
	sequence->cmd->fds[0] = old_fd;
	sequence->cmd->fds[1] = 1;
	return (n_cmd);
}

void	expand_ix(t_io_redir *ix, t_dictionary *env)
{
	char	*tmp;

	while (ix && ix->next)
	{
		tmp = ix->filename->text;
		ix->filename->text = expand_str(tmp, env);
		free(tmp);
		ix = ix->next;
	}
}

void	expand_pipe_seq(t_cmd_pipe *sequence, t_dictionary *env)
{
	char	*tmp;
	t_cmd	*cmd;
	char	**cmd_array;
	int		i;

	while (sequence)
	{
		cmd = sequence->cmd;
		while (cmd)
		{
			i = -1;
			cmd_array = (char **)cmd->cmd->darray;
			while (cmd_array[++i])
			{
				tmp = cmd_array[i];
				cmd_array[i] = expand_str(tmp, env);
				free(tmp);
			}
			expand_ix(cmd->cmd_prefix, env);
			expand_ix(cmd->cmd_suffix, env);
			cmd = cmd->next;
		}
		sequence = sequence->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_str.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 20:04:37 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/17 11:02:25 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "expansion.h"

void	no_se_pon_nombre_2(char *str, t_utils *utils, t_dictionary *env)
{
	char	*tmp_str;
	char	*env_var_name;
	char	*env_var_value;
	char	*trimmed_var;

	trimmed_var = NULL;
	env_var_value = NULL;
	tmp_str = utils->expanded_str;
	env_var_name = ft_substr(str, utils->i, utils->len_env_var - utils->i);
	if (!env_var_name)
		return (free(tmp_str), free(utils->expanded_str));
	trimmed_var = ft_strtrim(env_var_name, " \t\r");
	if (ft_strncmp(trimmed_var, " ", 2))
	{
		env_var_value = dict_get(env, env_var_name);
		if (!env_var_value)
			env_var_value = "";
	}
	free(trimmed_var);
	utils->expanded_str = ft_strjoin(utils->expanded_str, env_var_value);
	utils->i = (free(tmp_str), free(env_var_name), utils->len_env_var - 1);
}

int	nose_pon_nombre(t_dictionary *env, char *str, t_utils *utils)
{
	if (utils->state == ENV_VAR)
	{
		utils->state = utils->old_state;
		utils->old_state = ENV_VAR;
		utils->len_env_var = utils->i;
		if (utils->state != DOUBLE_QUOTE && str[utils->i] == '\'')
			utils->state = SINGLE_QUOTE;
		else
		{
			if (is_special_var(&str[utils->len_env_var]))
				utils->len_env_var++;
			else if (!is_special_var(&str[utils->len_env_var]))
			{
				while (ft_isalnum(str[utils->len_env_var]))
				{
					utils->len_env_var++;
					if (!ft_isalpha(str[utils->i]))
						break ;
				}
			}
			no_se_pon_nombre_2(str, utils, env);
		}
		return (1);
	}
	return (0);
}

int	expand_quotes(char *str, t_utils *utils)
{
	if (utils->state == DOUBLE_QUOTE)
	{
		utils->old_state = utils->state;
		if (str[utils->i] == '"')
			utils->state = WORD;
		else if ((str[utils->i] == '$' && ft_isalpha(str[utils->i + 1]))
			|| (str[utils->i] == '$' && is_special_var(&str[utils->i + 1])))
			utils->state = ENV_VAR;
		else
			join_char(&utils->expanded_str, &str[utils->i]);
		return (1);
	}
	else if (utils->state == SINGLE_QUOTE)
	{
		utils->old_state = utils->state;
		if (str[utils->i] == '\'')
			utils->state = WORD;
		else
			join_char(&utils->expanded_str, &str[utils->i]);
		return (1);
	}
	return (0);
}

char	*expand_str(char *str, t_dictionary *env)
{
	t_utils	utils;

	utils = ((void)env, (t_utils){0});
	utils.expanded_str = ft_strdup("");
	utils.state = WORD;
	utils.old_state = WORD;
	while (str[utils.i])
	{
		if (utils.state == WORD)
		{
			utils.old_state = utils.state;
			if (str[utils.i] == '"')
				utils.state = DOUBLE_QUOTE;
			else if (str[utils.i] == '\'')
				utils.state = SINGLE_QUOTE;
			else if (is_env_var(str, utils))
				utils.state = ENV_VAR;
			else
				join_char(&utils.expanded_str, &str[utils.i]);
		}
		else if (!expand_quotes(str, &utils))
			nose_pon_nombre(env, str, &utils);
		utils.i++;
	}
	return (utils.expanded_str);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42madrid.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 20:10:58 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/16 20:22:57 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "expansion.h"

int	is_env_var(char *str, t_utils utils)
{
	return ((str[utils.i] == '$' && ft_isalnum(str[utils.i + 1]))
		|| (str[utils.i] == '$' && str[utils.i + 1] == '\'')
		|| (str[utils.i] == '$' && str[utils.i + 1] == '"')
		|| (str[utils.i] == '$' && is_special_var(&str[utils.i + 1])));
}

int	is_for_expand_str(char *str)
{
	if (!ft_strchr(str, '"') && !ft_strchr(str, '\'') && !ft_strchr(str, '$'))
		return (0);
	return (1);
}

void	join_char(char **expanded_str, char *str)
{
	char	*tmp_str;
	char	c[2];

	tmp_str = *expanded_str;
	c[0] = *str;
	c[1] = '\0';
	*expanded_str = ft_strjoin(*expanded_str, c);
	free(tmp_str);
}

int	is_special_var(char *var)
{
	if (!ft_strncmp(var, "?", 1) || !ft_strncmp(var, "0", 1))
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/22 17:54:02 by alvmoral          #+#    #+#             */
/*   Updated: 2024/08/25 20:43:06 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

int	ft_atoi(const char *str)
{
	int	signo;
	int	value;

	value = 0;
	signo = 0;
	while ((*str >= 9 && *str <= 13) || *str == 32)
		str++;
	if (*str == '-' || *str == '+')
	{
		if (*str == '-')
			signo++;
		str++;
	}
	while (*str >= '0' && *str <= '9')
	{
		value = (*str - '0') + value * 10;
		str++;
	}
	if (signo % 2 != 0)
		value *= -1;
	return (value);
}

// int main()
// {
//     printf("mine: %i\n", ft_atoi("\n\t-21m34"));
//     printf("atoi: %i", atoi("\n\t-21m34"));
//     return (0);
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bzero.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/12 13:57:05 by alvmoral          #+#    #+#             */
/*   Updated: 2024/07/17 11:22:02 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	ft_bzero(void *s, size_t n)
{
	if (n > 0)
	{
		while (n--)
		{
			*(char *) s = 0;
			s++;
		}
	}
}

// int	main()
// {
// 	char	s[12] = "Hola";
// 	char	ptr[12] = "Hola";

// 	ft_bzero(s, 3);
// 	printf("size: %lu\t s: %s\n", sizeof(s), s);
// 	bzero(ptr, 3);
// 	printf("size: %lu\t ptr: %s\n", sizeof(ptr), ptr);
// 	return (0);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/14 16:52:04 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 15:28:09 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	*ft_calloc(size_t count, size_t size)
{
	void	*ptr;

	if (count && size && SIZE_MAX / count < size)
		return (NULL);
	ptr = malloc(count * size);
	if (ptr == NULL)
		return (NULL);
	ft_bzero(ptr, count * size);
	return (ptr);
}
// int main()
// {

// 	// This pointer will hold the
// 	// base address of the block created
// 	char** ptr;
// 	int n, i;

// 	// Get the number of elements for the array
// 	n = 7;
// 	printf("Enter number of elements: %d\n", n);

// 	// Dynamically allocate memory using calloc()
// 	ptr = (char**)ft_calloc(n, 7);

// 	if (ptr == NULL) {
// 		printf("Memory not allocated.\n");
// 		exit(0);
// 	}
// 	else {
// 		for (i = 0; i < n; ++i) {
// 			ptr[i] = "Frente";
// 		}

// 		// Print the elements of the array
// 		printf("The elements of the array are: ");
// 		for (i = 0; i < n; ++i) {
// 			printf("%s, ", ptr[i]);
// 		}
// 		free(ptr);
// 	}

// 	return 0;
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_chtoa.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/09 19:15:35 by alvmoral          #+#    #+#             */
/*   Updated: 2024/07/06 21:07:35 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

int	ft_chtoa_w(unsigned int c)
{
	int	counter;

	counter = write(1, &c, 1);
	return (counter);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_free_array.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/10 17:56:00 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/17 12:35:20 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	ft_free_array(char **marr)
{
	char			*free_ptr;
	unsigned int	i;

	i = 0;
	while (marr[i])
	{
		free_ptr = marr[i];
		i++;
		free(free_ptr);
	}
	free(marr);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalnum.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/20 16:33:47 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 15:00:06 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

int	ft_isalnum(int c)
{
	if (ft_isalpha(c) || ft_isdigit(c))
		return (1);
	else
		return (0);
}

// int main()
// {
//     int c = 80 ;
//     printf("mine: %d\n", ft_isalnum(c));
//     printf("orig: %d", isalnum(c));
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalpha.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/20 16:13:34 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 15:00:09 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

int	ft_isalpha(int c)
{
	if (c >= 65 && c <= 90)
		return (1);
	else if (c >= 97 && c <= 122)
		return (1);
	else
		return (0);
}

// int main(void)
// {
// 	int	c;

// 	c = 102;
//     printf("num: %d\n", isalpha(c));
// 	printf("num: %d", ft_isalpha(c));
//     return (0);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isascii.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/20 16:46:26 by alvmoral          #+#    #+#             */
/*   Updated: 2024/03/27 01:17:15 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

int	ft_isascii(int c)
{
	if (c >= 0 && c <= 127)
		return (1);
	else
		return (0);
}

// int main(void)
// {
// 	int	c;

// 	c = 102;
//     printf("num: %d\n", isascii(c));
// 	printf("num: %d", ft_isacii(c));
//     return (0);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isdigit.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/20 16:28:19 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 15:00:14 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

int	ft_isdigit(int c)
{
	if (c >= 48 && c <= 57)
		return (1);
	else
		return (0);
}

// int	main()
// {
// 	int	c = 58;
// 	printf("mine: %d\n", ft_isdigit(c));
// 	printf("isdigit: %d", isdigit(c));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isprint.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/27 01:17:31 by alvaro            #+#    #+#             */
/*   Updated: 2024/04/01 13:40:08 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

int	ft_isprint(int c)
{
	if (c >= 32 && c <= 126)
		return (1);
	else
		return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/16 19:42:14 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/04 18:17:08 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

static int	get_len(int nb)
{
	long	number;
	long	dec;

	number = (long) nb;
	dec = 1;
	if (number < 0)
		number *= -1;
	if (number == 0)
		dec *= 10;
	while (dec <= number)
		dec *= 10;
	return (dec / 10);
}

static int	get_memory(int nb)
{
	long	number;
	long	dec;
	int		contador;

	number = (long) nb;
	dec = 1;
	contador = 0;
	if (number < 0)
	{
		number *= -1;
		contador++;
	}
	if (number == 0)
		return (1);
	while (dec <= number)
	{
		contador++;
		dec *= 10;
	}
	return (contador);
}

static void	loop(char *ptr, long dlen, long lnb, int *i)
{
	int	digit;

	while (dlen > 0)
	{
		digit = lnb / dlen;
		ptr[*i] = digit + '0';
		lnb -= digit * dlen;
		*i = *i + 1;
		dlen /= 10;
	}
}

char	*ft_itoa(int nb)
{
	int		dlen;
	int		i;
	long	lnb;
	char	*ptr;

	dlen = get_len(nb);
	lnb = (long) nb;
	i = 0;
	ptr = (char *) malloc(get_memory(nb) + 1);
	if (ptr == NULL)
		return (NULL);
	if (lnb < 0)
	{
		ptr[i++] = '-';
		lnb *= -1;
	}
	loop(ptr, dlen, lnb, &i);
	ptr[i] = '\0';
	return (ptr);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa_w.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/11 22:01:37 by alvmoral          #+#    #+#             */
/*   Updated: 2024/07/06 21:05:59 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

static int	get_len(int nb)
{
	long	number;
	long	dec;

	number = (long) nb;
	dec = 1;
	if (number < 0)
		number *= -1;
	if (number == 0)
		dec *= 10;
	while (dec <= number)
		dec *= 10;
	return (dec / 10);
}

int	ft_itoa_w(int nb)
{
	int		dlen;
	int		contador;
	long	lnb;
	int		digit;
	char	printed_digit;

	dlen = get_len(nb);
	lnb = (long) nb;
	contador = 0;
	if (lnb < 0)
	{
		contador += write(1, "-", 1);
		lnb *= -1;
	}
	while (dlen > 0)
	{
		digit = lnb / dlen;
		printed_digit = digit + '0';
		contador += write(1, &printed_digit, 1);
		lnb -= digit * dlen;
		dlen /= 10;
	}
	return (contador);
}

// void	manage_negatives(int *lnb, int *contador)
// {
// 	if (*lnb < 0)
// 	{
// 		*contador += write(1, "-", 1);
// 		*lnb = *lnb * -1;
// 	}
// }

// int	ft_itoa_w(unsigned int nb)
// {
// 	long			digit;
// 	int				dlen;
// 	long			lnb;
// 	unsigned char	print_digit;
// 	int				contador;

// 	lnb = (int) nb;
// 	dlen = get_len(lnb);
// 	contador = 0;
// 	printf("lnb: %li\n", lnb);
// 	manage_negatives(&lnb, &contador);
// 	if (lnb == 2147483648)
// 	while (dlen > 0)
// 	{
// 		digit = lnb / dlen;
// 		//printf("digito: %li,  lnb: %li,  dlen: %i\n", digit ,lnb, dlen);
// 		print_digit = digit + '0';
// 		contador += write(1, &print_digit, 1);
// 		lnb -= digit * dlen;
// 		dlen /= 10;
// 	}
// 	return (contador);
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_back.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/01 13:26:23 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/05 21:21:43 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	ft_lstadd_back(t_list **lst, t_list *new)
{
	t_list	*list;
	t_list	*holder;

	list = *lst;
	if (list == NULL)
		*lst = new;
	if (list != NULL)
	{
		while (list != NULL)
		{
			holder = list;
			list = list->next;
		}
		holder->next = new;
	}
}

// int	main(void)
// {
// 	t_list	*new = &(t_list) {NULL, NULL};
// 	//t_list	*after = &(t_list) {NULL, NULL};
// 	// t_list	*list = &(t_list) {NULL, NULL};
// 	//double	val = 12.3;

// 	//ft_lstadd_front(&list, (void *) 0);
// 	//after->content = (void *) &val;
// 	ft_lstadd_back(&new, (void *) 0);
// 	printf("contenido_last: %f\n", *(double *) ft_lstlast(new)->content);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_front.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/01 13:26:43 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/05 21:20:03 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	ft_lstadd_front(t_list **lst, t_list *new)
{
	t_list	*list;

	list = *lst;
	new->next = list;
	*lst = new;
}
//int	main()
//{
	//t_list	new = (t_list) {"c", NULL};
	//t_list	*list = ft_lstnew("Hola");
	//ft_lstadd_front(&list, &new);
	//printf("conte: %s\n", (char *) new.content);
	//printf("next: %s\n", (char *) new.next->content);	
	//free(list);
//}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstclear_bonus.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/04 22:23:26 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 15:36:07 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	ft_lstclear(t_list **lst, void (*del) (void *))
{
	t_list	*holder;
	t_list	*list;

	list = *lst;
	while (list != NULL)
	{
		holder = list;
		list = list->next;
		del(holder->content);
		free(holder);
	}
	*lst = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstdelone_bonus.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/01 13:26:54 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 15:32:42 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	ft_lstdelone(t_list *lst, void (*del)(void*))
{
	del(lst->content);
	free(lst);
}

void	del(void *content)
{
	free(content);
}

//int	main()
//{
	//t_list	*new = ft_lstnew(NULL);
	//t_list	*after = ft_lstnew(NULL);
	//t_list	*list = ft_lstnew(NULL);
	//double	val = 12.3;

	//ft_lstadd_front(&list, new);
	//after->content = (void *) &val;
	//ft_lstadd_back(&new, after);
	//ft_lstdelone(after, del);
	//printf("contenido_last: %f\n", *(double *) ft_lstlast(new)->content);
	//free(new);
	//free(after);
	//free(list);
//}

/*
A ti te pasan el nodo a liberar y tu
lo que tienes que hacer es pasarle la funcion
del que lo libera.

Si no alocas memoria para content, te da:
free(): invalid pointer
Aborted.

Además, como solo está permitida la función
free(), se asume que la alocaci'on ha de 
hacerse en las otras funciones.
*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstiter_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/04 22:44:55 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 15:36:47 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	ft_lstiter(t_list *lst, void (*f) (void *))
{
	t_list	*holder;

	while (lst != NULL)
	{
		holder = lst;
		lst = lst->next;
		f(holder->content);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstlast.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/01 13:27:28 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/05 21:23:52 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

t_list	*ft_lstlast(t_list *lst)
{
	t_list	*holder;

	holder = NULL;
	while (lst != NULL)
	{
		holder = lst;
		lst = lst->next;
	}
	return (holder);
}

//int	main(void)
//{
	//t_list	*new = &(t_list) {NULL, NULL};
	//t_list	*after = &(t_list) {NULL, NULL};
	//t_list	*list = &(t_list) {NULL, NULL};
	//double	val = 12.3;
	//list->content = (void *) &val;

	//ft_lstadd_front(&list, new);
	//ft_lstadd_front(&after, list);
	//ft_lstlast(new)->content = &val;
	//printf("contenido_last: %f\n", *(double *) ft_lstlast(new)->content);
//}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstmap_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/06 14:27:57 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 15:31:55 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

t_list	*ft_lstmap(t_list *lst, void *(*f) (void *), void (*del)(void *))
{
	t_list	*new_node;
	t_list	*first_node;

	if (lst == NULL || !f || !del)
		return (NULL);
	first_node = NULL;
	while (lst != NULL)
	{
		new_node = ft_lstnew(NULL);
		if (new_node == NULL)
		{
			ft_lstclear(&first_node, del);
			return (NULL);
		}
		new_node->content = f(lst->content);
		ft_lstadd_back(&first_node, new_node);
		lst = lst->next;
	}
	return (first_node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/01 13:28:05 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/04 22:09:48 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

t_list	*ft_lstnew(void *content)
{
	t_list	*new_n;

	new_n = (t_list *) malloc(sizeof(t_list));
	if (new_n == NULL)
		return (NULL);
	new_n->content = content;
	new_n->next = NULL;
	return (new_n);
}

// int	main()
// {
// 	t_list	*nodo;
// 	char	conte[] = "Si yo te contara...";

// 	nodo = ft_lstnew(conte);
// 	printf("conte: %s\n", (char *) nodo->content);
// 	printf("next: %s", (char *) nodo->next);
// 	free(nodo);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstsize_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/01 13:28:28 by alvmoral          #+#    #+#             */
/*   Updated: 2024/07/27 18:00:48 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

int	ft_lstsize(t_list *lst)
{
	int		contador;

	contador = 0;
	while (lst != NULL)
	{
		contador++;
		lst = lst->next;
	}
	return (contador);
}

//int	main(void)
//{
	//t_list	*new = &(t_list) {"c", NULL};
	//t_list	*after = &(t_list) {"after", NULL};
	//t_list	*list = &(t_list) {"Hola", NULL};
	//ft_lstadd_front(&list, new);
	//ft_lstadd_front(&after, list);
	//printf("len: %i\n", ft_lstsize(new));
//}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/13 17:32:29 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 14:55:53 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	*ft_memchr(const void *s, int c, size_t n)
{
	unsigned char	*ptrs;

	ptrs = (unsigned char *) s;
	while (n--)
	{
		if (*ptrs == (unsigned char)c)
			return (ptrs);
		ptrs++;
	}
	return (0);
}

// int	main()
// {
// 	char	s[] = "Hola";
// 	int		c = 108;

// 	printf("ocurrence: %s\n", (unsigned char *) ft_memchr(s, c, 4));
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/13 18:15:57 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 14:56:11 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

int	ft_memcmp(const void *s1, const void *s2, size_t n)
{
	unsigned char	*ptrs1;
	unsigned char	*ptrs2;

	ptrs1 = (unsigned char *) s1;
	ptrs2 = (unsigned char *) s2;
	while (n--)
	{
		if (*ptrs1 != *ptrs2)
			return (*ptrs1 - *ptrs2);
		ptrs1++;
		ptrs2++;
	}
	return (0);
}

// int main()
// {
//     char    s1[] = "xerro";
//     char    s2[] = "perro";
//     int     valor;

//     valor = ft_memcmp(s1, s2, sizeof(s1));
//     printf("valor: %d\n", valor);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcpy.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/12 17:41:45 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/17 13:03:05 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	*ft_memcpy(void *dst, const void *src, size_t n)
{
	unsigned char	*ptrdst;
	unsigned char	*ptrsrc;
	size_t			i;

	if (dst == NULL && src == NULL)
		return (NULL);
	ptrdst = (unsigned char *) dst;
	ptrsrc = (unsigned char *) src;
	i = 0;
	while (n--)
	{
		ptrdst[i] = ptrsrc[i];
		i++;
	}
	return (ptrdst);
}

// int	main()
// {
// 	// char	dst[20] = "Hola";
// 	// char	src[20] = "Adios.";
// 	float	dst = 9;
// 	float	src = 2;

// 	ft_memcpy(&dst, &src, 1);
// 	printf("dst: %f\n", dst);
// 	memcpy(&dst, &src, sizeof(dst));
// 	printf("fun: %f\n", dst);

// }

/*
Si n vale cualquier otra cosa 
y es un puntero nulo (void *),
 da segmentation fault. Controla ese caso.
*/

/*
 * Probar para structs.
 *
 * Para arrays, para ints.
 *
 * Comprobar que no se solapan.
 *
 * si se cortan cuando n = 0.
 *
 * probar para overlapping.
 */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memmove.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/22 15:58:49 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 14:56:31 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

static int	set_index(size_t *i, size_t *j, size_t len, int diff)
{
	int	flag;

	if (diff <= 0)
	{
		flag = 1;
		*i = 0;
		*j = 0;
	}
	else
	{
		flag = 0;
		*i = len -1;
		*j = len -1;
	}
	return (flag);
}

void	*ft_memmove(void *dst, const void *src, size_t len)
{
	char	*pdst;
	char	*psrc;
	size_t	i;
	size_t	j;
	int		flag;

	if (dst == NULL && src == NULL)
		return (NULL);
	pdst = (char *) dst;
	psrc = (char *) src;
	flag = set_index(&i, &j, len, pdst - psrc);
	while (len--)
	{
		if (flag)
			pdst[i++] = psrc[j++];
		else
			pdst[i--] = psrc[j--];
	}
	return (dst);
}

// int	main(void)
// {
// 	char	dst[20] = "Hola";
// 	char	dsto[20] = "Hola";
// 	char	src[20] = "Adios.";
// 	float	dst = 60.344;
// 	float	dsto = 60.344;
// 	float	src = -123.76;

// 	ft_memmove(&dst, &src, 4);
// 	printf("dst: %f\n", dst);
// 	memmove(&dsto, &src, 4);
// 	printf("fun: %f\n", dsto);
// 	return (0);
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/11 20:03:48 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/15 16:14:42 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	*ft_memset(void *b, int c, size_t len)
{
	size_t			i;
	unsigned char	*str;

	str = (unsigned char *) b;
	i = 0;
	while (i < len)
	{
		str[i] = c;
		i++;
	}
	return (b);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/27 15:53:08 by alvaro            #+#    #+#             */
/*   Updated: 2024/07/06 21:08:21 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

static void	write_arguments(char const *s1, va_list argum, int *counter)
{
	char	format;

	format = *s1;
	if (format == 'u')
		*counter += ft_utoa_w(va_arg(argum, unsigned int));
	else if (format == 'x' || format == 'X')
		*counter += ft_xtoa_w(va_arg(argum, unsigned int), format);
	else if (format == 'p')
		*counter += ft_ptoa_w(va_arg(argum, unsigned long long));
	else if (format == 's')
		*counter += ft_strtoa_w(va_arg(argum, char *));
	else if (format == 'c')
		*counter += ft_chtoa_w(va_arg(argum, int));
	else if (format == 'i' || format == 'd')
		*counter += ft_itoa_w(va_arg(argum, int));
	else if (format == '%')
		*counter += write(1, &format, 1);
	else
		return ;
}

int	ft_printf(char const *s1, ...)
{
	int		counter;
	int		control;
	size_t	i;
	va_list	argum;

	i = 0;
	counter = 0;
	va_start(argum, s1);
	while (s1[i])
	{
		if (s1[i] == '%' && s1[i++] != '\0')
		{
			control = counter;
			write_arguments(&s1[i], argum, &counter);
			if (control > counter)
				return (-1);
		}
		else
			counter += write(1, &s1[i], 1);
		i++;
	}
	va_end(argum);
	return (counter);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ptoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/07 19:50:02 by alvaro            #+#    #+#             */
/*   Updated: 2024/07/06 21:05:35 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

static long long	get_len_hex(unsigned long long nb)
{
	unsigned long long	holder;
	unsigned long long	hex;

	holder = nb;
	hex = 0x01;
	while (holder >= 0x10)
	{
		holder /= 0x10;
		hex *= 0x10;
	}
	return (hex);
}

static int	write_digit(unsigned long long digito)
{
	char	ch;

	if (digito <= 9)
		ch = digito + '0';
	else
	{
		digito = digito - 10;
		ch = digito + 'a';
	}
	return (write(1, &ch, 1));
}

int	ft_ptoa_w(unsigned long long nb)
{
	unsigned long long	len;
	unsigned long long	digito;
	int					contador;

	contador = 0;
	if (nb == 0)
		return (write(1, "(nil)", 5));
	len = get_len_hex(nb);
	contador += write(1, "0x", 2);
	while (len > 0x0)
	{
		digito = nb / len;
		contador += write_digit(digito);
		nb -= digito * len;
		len /= 0x10;
	}
	return (contador);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/18 14:43:39 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 14:57:31 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	ft_putchar_fd(char c, int fd)
{
	write(fd, &c, 1);
}

// int	main()
// {
// 	int	fd;

// 	fd = open("pp.txt", O_APPEND);
// 	char	c = 'l';
// 	ft_putchar_fd(c, fd);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/18 15:12:14 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 14:57:52 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	ft_putendl_fd(char *s, int fd)
{
	while (*s)
	{
		write(fd, s, 1);
		s++;
	}
	write(fd, "\n", 1);
}

// int	main()
// {
// 	char	s[] = "Adios";
// 	int		fd;

// 	fd = open("pp.txt", O_WRONLY | O_TRUNC);
// 	ft_putendl_fd(s, fd);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/18 15:22:25 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 14:28:52 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

static int	get_len(int nb)
{
	long	number;
	long	dec;

	number = (long) nb;
	dec = 1;
	if (number < 0)
		number *= -1;
	if (number == 0)
		dec *= 10;
	while (dec <= number)
		dec *= 10;
	return (dec / 10);
}

void	ft_putnbr_fd(int n, int fd)
{
	int		dlen;
	int		i;
	int		digit;
	long	lnb;
	char	printn;

	dlen = get_len(n);
	lnb = (long) n;
	i = 0;
	if (lnb < 0)
	{
		write(fd, "-", 1);
		lnb *= -1;
	}
	while (dlen > 0)
	{
		digit = lnb / dlen;
		printn = digit + '0';
		write(fd, &printn, 1);
		lnb -= digit * dlen;
		i = i + 1;
		dlen /= 10;
	}
}

// int	main()
// {
// 	int	n = 98298;
// 	int	fd;

// 	fd = open("pp.txt", O_WRONLY | O_TRUNC);
// 	ft_putnbr_fd(n, fd);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/18 14:58:19 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 14:58:11 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	ft_putstr_fd(char *s, int fd)
{
	while (*s)
	{
		write(fd, s, 1);
		s++;
	}
}

// int	main()
// {
// 	char	s[] = "Hola";
// 	int	fd;

// 	fd = open("pp.txt", O_WRONLY | O_APPEND);
// 	ft_putstr_fd(s, fd);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/06 14:29:29 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 14:58:15 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

static int	len_cal(char const *s, char c)
{
	int	token;
	int	i;

	i = 0;
	token = 0;
	while (s[i])
	{
		if (s[i] != c && (s[i + 1] == c || s[i + 1] == '\0'))
			token += 1;
		i++;
	}
	return (token);
}

static void	get_sep(unsigned int *start, unsigned int *next,
char const *s, char c)
{
	*next = 0;
	while (s[*start] && s[*start] == c)
	{
		*start = *start + 1;
	}
	while (s[*start] && s[*start] != c)
	{
		*next = *next + 1;
		*start = *start + 1;
	}
}

static char	**release(char **marr, int i)
{
	while (i--)
		free(marr[i]);
	free(marr);
	return (NULL);
}

void	intialize_indexes(int *i, unsigned int *start, unsigned int *next)
{
	*i = 0;
	*start = 0;
	*next = 0;
}

char	**ft_split(char const *s, char c)
{
	int					i;
	unsigned int		start;
	unsigned int		next;
	char				**marr;

	intialize_indexes(&i, &start, &next);
	if (s == NULL)
		return (NULL);
	marr = (char **) malloc((len_cal(s, c) + 1) * sizeof(char *));
	if (marr == NULL)
		return (NULL);
	while (i < len_cal(s, c))
	{
		get_sep(&start, &next, s, c);
		if (next > 0)
			marr[i] = ft_substr(s, start - next, next);
		else
			marr[i] = ft_substr(s, start - next, 1);
		if (marr[i] == NULL)
			return (release(marr, i));
		i++;
	}
	marr[i] = NULL;
	return (marr);
}

// int	main(void)
// {
// 	char	**marr = ft_split("", '^');
// 	int		i = 0;

// 	if (len_cal("", '^') > 0)
// 	{
// 		while (marr[i] != NULL)
// 		{
// 			printf("%s\n", marr[i]);
// 			i++;
// 		}
// 		while (i > 0)
// 		{
// 			free(marr[i - 1]);
// 			i--;
// 		}
// 	}
// 	else
// 		printf("marr 0: %s", marr[0]);
// 	return (0);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/13 21:04:11 by alvmoral          #+#    #+#             */
/*   Updated: 2024/08/16 17:10:41 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

char	*ft_strchr(const char *s, int c)
{
	c = (char) c;
	if (s == NULL)
		return (NULL);
	while (*s)
	{
		if (*s == c)
			return ((char *) s);
		s++;
	}
	if (*s == c)
		return ((char *) s);
	else
		return (0);
}

// int main()
// {
//     const char s[] = "HOLLLa";
//     printf("str: %s\n", ft_strchr(s, 'O'));
//     printf("str: %s\n", strchr(s, 'O'));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/08/20 17:51:55 by alvmoral          #+#    #+#             */
/*   Updated: 2025/02/22 17:18:20 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

int	ft_strcmp(char *s1, char *s2)
{
	int	i;

	if (!s1 || !s2)
		return (-1);
	i = 0;
	while (s1[i] == s2[i] && s1[i] != '\0' && s2[i] != '\0')
	{
		i++;
	}
	return (s1[i] - s2[i]);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/14 13:09:27 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/17 13:04:53 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

char	*ft_strdup(const char *s1)
{
	char	*ptr;
	int		len;

	if (!s1)
		return (NULL);
	len = 0;
	while (s1[len])
		len++;
	ptr = (char *) malloc(len + 1);
	if (ptr == NULL)
		return (free(ptr), NULL);
	ft_memcpy(ptr, s1, len + 1);
	return (ptr);
}

// int	main()
// {
// 	const char	s1[] = "HAHAHA \0 tu me vois pas !";
// 	const char	s2[] = "HAHAHA \0 tu me vois pas !";
// 	char		*ptrm = ft_strdup(s1);
// 	char		*ptro = strdup(s2);
// 	printf("ptrm: %s\n", ptrm);
// 	printf("ptro: %s\n", ptro);
// 	free(ptrm);
// 	free(ptro);
// }

/*
 * Buscar si el resultado de malloc puede ser null.
 *
 * Hacer el make para importar libft.h.
 */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_striteri.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/16 22:47:12 by alvmoral          #+#    #+#             */
/*   Updated: 2024/03/27 01:02:37 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	ft_striteri(char *s, void (*f) (unsigned int, char*))
{
	unsigned int		i;

	i = 0;
	while (s[i])
	{
		f(i, &s[i]);
		i++;
	}
}

// char	rot_r(unsigned int r, char *c)
// {
// 	if ((int) r + *c < 255)
// 		*c += r;
// }

// int	main()
// {
// 	char const s[] = "Hola";
// 	char	*ptr;

// 	ptr = ft_strmapi(s, rot_r);
// 	printf("ptr: %s", ptr);
// 	free(ptr);
// }	
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/16 16:00:51 by alvmoral          #+#    #+#             */
/*   Updated: 2024/08/16 17:29:06 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

char	*ft_strjoin(char *s1, char *s2)
{
	char	*ptr;
	size_t	l1;
	size_t	l2;
	size_t	lt;

	l1 = ft_strlen(s1);
	l2 = ft_strlen(s2);
	lt = l1 + l2;
	ptr = (char *) malloc(lt * sizeof(char) + 1);
	if (ptr == NULL)
		return (NULL);
	while (l1 && *s1)
		*ptr++ = *s1++;
	while (l2 && *s2)
		*ptr++ = *s2++;
	*ptr = '\0';
	return (ptr - lt);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcat.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/06 14:30:47 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 14:30:48 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

size_t	ft_strlcat(char *dst, const char *src, size_t dstsize)
{
	size_t		tlen;
	size_t		catlen;
	size_t		i;

	i = 0;
	tlen = ft_strlen((const char *) dst) + ft_strlen(src);
	catlen = dstsize - ft_strlen((const char *) dst) - 1;
	while (*dst)
		dst++;
	if (tlen - ft_strlen(src) >= dstsize)
		return (dstsize + ft_strlen(src));
	if (catlen > ft_strlen(src))
		catlen = ft_strlen(src);
	while (i < catlen)
	{
		*dst = src[i];
		i++;
		dst++;
	}
	*dst = '\0';
	return (tlen);
}

// int main()
// {
// 	char	dstm[34] = "Hola";
// 	// char    dsto[4] = "B";	
//     // char    src[] = "esto";
// 	printf("len_mine: %zu\t mine_str: %s\n",
// 		ft_strlcat(dstm, "abcd", -1), dstm);
// }

/*
Dice en el man que en principio no hay que contemplar la posibilidad
de que dst sea mayor que dstsize; tambien que si dstsize es 0,
entonces no hace falta hacer el NUl ter, porque no se concatena nada.
*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcpy.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/06 14:31:28 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 14:31:29 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

size_t	ft_strlcpy(char *dst, const char *src, size_t dstsize)
{
	size_t	tlen;
	size_t	i;

	i = 0;
	tlen = ft_strlen(src);
	if (dstsize != 0)
	{
		while (i < dstsize -1 && src[i])
		{
			dst[i] = src[i];
			i++;
		}
		dst[i] = '\0';
	}
	return (tlen);
}

// int	main(void)
// {
// 	char		dst[] = "AAAAAAAAAA";
// 	char		dstp[] = "AAAAAAAAAA";
// 	char const	src[] = "coucou";
// 	int			dstsize = 8;

// 	// printf("blen: %zu \t dst: %s\n", strlcpy(dst, src, -1), dst);
// 	printf("blen: %zu \t dst: %s\n", ft_strlcpy(dstp, src, -1), dstp);
// 	printf("logic: %d", !strcmp(src, dstp) && dst[strlen(src) + 1] == 'A');
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlen.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/16 21:21:37 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/01 13:35:13 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

size_t	ft_strlen(const char *s)
{
	size_t	len;

	len = 0;
	if (s == NULL)
		return (0);
	while (*s)
	{
		len++;
		s++;
	}
	return (len);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strmapi.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/16 21:56:38 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/04 20:29:13 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

char	*ft_strmapi(char const *s, char (*f) (unsigned int, char))
{
	char	*str;
	int		i;
	int		len;

	i = 0;
	len = ft_strlen(s);
	str = (char *) malloc(len * sizeof(char) + 1);
	if (str == NULL)
		return (NULL);
	while (s[i])
	{
		str[i] = f(i, s[i]);
		i++;
	}
	str[i] = '\0';
	return (str);
}

//char addOne(unsigned int i, char c) {return (i + c);}

//int	main()
//{
	//char const s[] = ""; // ""
	//char	*ptr;

	//ptr = ft_strmapi(s, addOne);
	//printf("ptr: %s", ptr);
	//free(ptr);
//}

// Una varaible función se define igual que cualquier otra variable, 
//solo que también hay que incluir el tipo de parámetros. 
//Luego puedes pasarle cualquier
// función que tenga los parámetros indicados. 
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strncmp.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/13 20:03:16 by alvmoral          #+#    #+#             */
/*   Updated: 2025/02/25 10:43:45 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

int	ft_strncmp(char	*s1, char	*s2, unsigned int n)
{
	if (n == 0)
		return (0);
	if (!s1 && !s2)
		return (1);
	while (*s1 && *s2 && n > 0)
	{
		if (*s1 != *s2)
			return ((unsigned char) *s1 - (unsigned char) *s2);
		s1++;
		s2++;
		n--;
	}
	if (n > 0)
		return ((unsigned char) *s1 - (unsigned char) *s2);
	else
		return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strnstr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/13 20:31:44 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 14:58:49 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

char	*ft_strnstr(const char *haystack, const char *needle, size_t len)
{
	int		i;
	int		count;
	int		j;

	count = 0;
	while (needle[count])
		count++;
	if (count == 0)
		return ((char *) haystack);
	i = 0;
	j = 0;
	while (haystack[i] && len)
	{
		while ((needle[j] == haystack[i + j]) && len - j)
		{
			if (j + 1 == count)
				return ((char *)(haystack + i));
			j++;
		}
		j = 0;
		i++;
		len--;
	}
	return (0);
}

// int	main()
// {
// 	char	str[] = "AAAAAAAAA";
// 	///char	to_find[] = "ly";
// 	printf("mine: %s\n", ft_strnstr(str, str, ft_strlen(str)));
// 	printf("orig: %s", strnstr(str, str, ft_strlen(str)));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strrchr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/13 20:05:01 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/06 14:58:57 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

char	*ft_strrchr(const char *s, int c)
{
	const char	*sh;

	sh = 0;
	c = (char) c;
	while (*s)
	{
		if (*s == c)
			sh = s;
		s++;
	}
	if (*s == c)
		return ((char *) s);
	else
		return ((char *) sh);
}

// int main()
// {
//     const char s[] = "HOLLLa";
//     printf("str: %s\n", ft_strrchr(s, 'z'));
//     printf("str: %s\n", strrchr(s, 'z'));
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strtoa.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/09 14:38:56 by alvmoral          #+#    #+#             */
/*   Updated: 2024/07/06 21:08:00 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

int	ft_strtoa_w(char *str)
{
	int		counter;

	counter = 0;
	if (str == 0)
		return (write (1, "(null)", 6));
	while (*str)
		counter += write(1, str++, 1);
	return (counter);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strtrim.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/16 16:55:29 by alvmoral          #+#    #+#             */
/*   Updated: 2025/02/25 12:07:01 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

static unsigned char	*startcmp(const char *s1, const char *set)
{
	int				i;
	unsigned char	*ptrs1;

	i = 0;
	ptrs1 = (unsigned char *) s1;
	while (ptrs1[i])
	{
		if (ft_strchr(set, ptrs1[i]) == NULL)
			return (&ptrs1[i]);
		i++;
	}
	return (&ptrs1[i]);
}

static int	fin_cmp(unsigned char *ptrs1, const char *set)
{
	int	i;
	int	len_s1;

	len_s1 = ft_strlen((char *) ptrs1);
	i = 0;
	while (len_s1 > 0 && ptrs1[len_s1 - 1])
	{
		if (ft_strchr(set, ptrs1[len_s1 - i]) == NULL)
			return (len_s1 - i + 1);
		i++;
	}
	return (0);
}

char	*ft_strtrim(char const *s1, char const *set)
{
	int				end;
	unsigned char	*ptrs1;
	char			*ptr;

	if (s1 == NULL || set == NULL)
		return (NULL);
	ptrs1 = startcmp(s1, set);
	end = fin_cmp(ptrs1, set);
	ptr = (char *) malloc(end * sizeof(char) + 1);
	if (ptr == NULL)
		return (NULL);
	ft_memcpy(ptr, ptrs1, end);
	ptr[end] = '\0';
	return (ptr);
}

// int	main()
// {
// 	const char	s1[] = "      \t  ";
// 	const char	set[] = " \t\r"; //zsx, '\0' 
// 	char	*ptr;

// 	ptr = ft_strtrim(s1, set);
// 	printf("ptr: %s\n", ptr);
// 	free(ptr);	
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_substr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/16 15:42:12 by alvmoral          #+#    #+#             */
/*   Updated: 2024/04/03 16:55:52 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

char	*ft_substr(char const *s, unsigned int start, size_t len)
{
	char	*ptr;
	size_t	init;

	if (start > ft_strlen(s))
		len = 0;
	else if (len > ft_strlen(s) - start)
		len = ft_strlen(s) - start;
	ptr = (char *) ft_calloc(len + 1, sizeof(char));
	if (ptr == NULL)
		return (NULL);
	init = 0;
	while (s[init] && len--)
	{
		ptr[init++] = s[start++];
	}
	ptr[init] = ""[0];
	return (ptr);
}

// int	main()
// {
// 	char const	str[] = "1";
// 	char		*ptr;

// 	ptr = ft_substr(str, 90, 10000);
// 	printf("s: %s\n", ptr);
// 	//printf("cmp: %d\n", ft_strncmp("", ptr, 1));
// 	free(ptr);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tolower.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/22 21:27:35 by alvmoral          #+#    #+#             */
/*   Updated: 2024/03/27 01:24:10 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

int	ft_tolower(int c)
{
	if (c >= 65 && c <= 90)
		c += 32;
	return (c);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_toupper.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/27 01:15:14 by alvaro            #+#    #+#             */
/*   Updated: 2024/03/27 01:24:27 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

int	ft_toupper(int c)
{
	if (c >= 97 && c <= 122)
		c -= 32;
	return (c);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_utoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/07 19:50:18 by alvaro            #+#    #+#             */
/*   Updated: 2024/07/06 21:06:56 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

static unsigned long	get_len(unsigned int nb)
{
	unsigned long	hex;

	hex = 1;
	if (nb == 0)
		hex *= 10;
	while (hex <= nb)
		hex *= 10;
	return (hex / 10);
}

int	ft_utoa_w(unsigned int nb)
{
	unsigned int	len;
	unsigned long	digito;
	unsigned char	print_digit;
	int				contador;

	len = get_len(nb);
	contador = 0;
	while (len > 0)
	{
		digito = nb / len;
		print_digit = digito + '0';
		contador += write(1, &print_digit, 1);
		nb -= digito * len;
		len /= 10;
	}
	return (contador);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_xtoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/07 19:50:13 by alvaro            #+#    #+#             */
/*   Updated: 2024/07/06 21:06:44 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

static unsigned int	get_len_hex(unsigned int nb)
{
	unsigned long	hex;
	unsigned int	holder;

	hex = 0x01;
	if (nb == 0x00)
		hex *= 0x10;
	while (nb >= 0x01)
	{
		holder = nb / 0x10;
		nb = holder;
		hex *= 0x10;
	}
	return (hex / 0x10);
}

static int	write_digit(unsigned int digito, char c)
{
	char	ch;

	if (digito <= 9)
		ch = digito + '0';
	else
	{
		digito = digito - 10;
		ch = digito + 'a';
		if (c == 'X')
			ch = digito + 'A';
	}
	return (write(1, &ch, 1));
}

int	ft_xtoa_w(unsigned int nb, char c)
{
	unsigned int	len;
	unsigned int	digito;
	int				contador;

	contador = 0;
	len = get_len_hex(nb);
	while (len > 0x0)
	{
		digito = nb / len;
		contador += write_digit(digito, c);
		nb -= digito * len;
		len /= 0x10;
	}
	return (contador);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42madrid.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/06 14:38:04 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/19 21:57:29 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/get_next_line.h"

// char	*take_after_new_line(char *temp)
// {
// 	int		i;
// 	int		j;
// 	char	*dest;

// 	i = 0;
// 	while (temp[i] && temp[i] != '\n')
// 		i++;
// 	if (!temp[i])
// 	{
// 		free(temp);
// 		return (NULL);
// 	}
// 	dest = malloc(sizeof(char) * (ft_strlen(temp) - i + 1));
// 	if (!dest)
// 		return (free(temp), NULL);
// 	j = 0;
// 	while (temp[i])
// 		dest[j++] = temp[++i];
// 	dest[j] = '\0';
// 	free(temp);
// 	return (dest);
// }

// char	*take_until_new_line(char *str)
// {
// 	int		i;
// 	char	*dest;

// 	i = 0;
// 	if (!str[i])
// 		return (NULL);
// 	while (str && str[i] && str[i] != '\n')
// 		i++;
// 	if (str[i] == '\n')
// 		i++;
// 	dest = malloc(sizeof(char) * (i + 1));
// 	if (!dest)
// 		return (NULL);
// 	i = 0;
// 	while (str && str[i] && str[i] != '\n')
// 	{
// 		dest[i] = str[i];
// 		i++;
// 	}
// 	if (str[i] == '\n')
// 		dest[i++] = '\n';
// 	dest[i] = '\0';
// 	return (dest);
// }

// char	*read_until_new_line(int fd, char **str)
// {
// 	char	*buff;
// 	char	*str_tmp;
// 	int		bytes_read;

// 	if (!*str)
// 	{
// 		*str = malloc(1 * sizeof(char));
// 		*str[0] = '\0';
// 	}
// 	if (!*str)
// 		return (NULL);
// 	buff = malloc((BUFFER_SIZE + 1) * sizeof(char));
// 	if (!buff)
// 		return (free(*str), NULL);
// 	bytes_read = 1;
// 	while (!ft_strchr(*str, '\n') && bytes_read != 0)
// 	{
// 		bytes_read = read(fd, buff, BUFFER_SIZE);
// 		if (bytes_read == -1)
// 			return (free(buff), free(*str), NULL);
// 		if (bytes_read == 0)
// 			return (free(buff), free(*str), NULL);
// 		buff[bytes_read] = '\0';
// 		str_tmp = *str;
// 		*str = ft_strjoin(*str, buff);
// 		free(str_tmp);
// 		if (!*str)
// 			return (free(buff), NULL);
// 	}
// 	return (free(buff), *str);
// }

// char	*get_next_line(int fd)
// {
// 	static char	*str;
// 	char		*line;

// 	if (fd < 0 || BUFFER_SIZE <= 0)
// 		return (NULL);
// 	str = read_until_new_line(fd, &str);
// 	if (!str)
// 		return (0);
// 	line = take_until_new_line(str);
// 	if (!line)
// 	{
// 		free(line);
// 		free(str);
// 		str = NULL;
// 		return (NULL);
// 	}
// 	str = take_after_new_line(str);
// 	return (line);
// }

#include "../libft/include/libft.h"
#include <stdlib.h>
#include <unistd.h>

char	*strjoin_and_free(char *s1, char *s2)
{
	char	*joined;
	int	i;
	size_t	j;
	
	joined = (char *)malloc(sizeof(char) * (ft_strlen(s1) + ft_strlen(s2) + 1));
	if (!joined)
		return (NULL);
	i = 0;
	j = 0;
	while (s1 && s1[j])
		joined[i++] = s1[j++];
	j = 0;
	while (s2 && s2[j])
		joined[i++] = s2[j++];
	joined[i] = '\0';
	free(s1);
	return (joined);
}

char	*get_next_line(int fd)
{
	static char	buffer[BUFFER_SIZE];
	static int	buffer_read = 0;
	static int	buffer_pos = 0;
	char		*line = NULL;
	char		temp[2];
	
	if (fd < 0 || BUFFER_SIZE <= 0)
		return (NULL);
	while (1)
	{
		if (buffer_pos >= buffer_read)
		{
			buffer_read = read(fd, buffer, BUFFER_SIZE);
			buffer_pos = 0;
			if (buffer_read <= 0)
				break ;
		}
		temp[0] = buffer[buffer_pos++];
		temp[1] = '\0';
		line = strjoin_and_free(line, temp);
		if (temp[0] == '\n')
			break ;
	}
	return (line);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42madrid.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/07 15:38:11 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/19 21:55:00 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/get_next_line.h"

// char	*ft_strchr(const char *s, int c)
// {
// 	int	i;

// 	i = 0;
// 	while (s[i])
// 	{
// 		if (s[i] == (unsigned char) c)
// 			return ((char *)&s[i]);
// 		i++;
// 	}
// 	if ((unsigned char) c == '\0')
// 		return ((char *)&s[i]);
// 	return (0);
// }

// char	*ft_strjoin(char *s1, char *s2)
// {
// 	char	*str;
// 	int		i;
// 	int		j;

// 	if (s1 == NULL && s2 == NULL)
// 		return (free(s1), NULL);
// 	i = 0;
// 	j = 0;
// 	str = (char *)malloc((ft_strlen(s1) + ft_strlen(s2) + 1)
// 			* sizeof(char));
// 	if (str == NULL)
// 		return (free(s1), NULL);
// 	while (s1 != NULL && s1[i] != '\0')
// 	{
// 		str[i] = s1[i];
// 		i++;
// 	}
// 	while (s2 != NULL && s2[j] != '\0')
// 	{
// 		str[i + j] = s2[j];
// 		j++;
// 	}
// 	str[i + j] = '\0';
// 	free(s1);
// 	return (str);
// }

// size_t	ft_strlen(const char *s)
// {
// 	size_t	i;

// 	i = 0;
// 	while (s[i] != '\0')
// 		i++;
// 	return (i);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sort_strings.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lvez-dia <lvez-dia@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 17:59:36 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/15 16:01:40 by lvez-dia         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "include/libft.h"

void	sort_strings(char **strings, int n)
{
	char	*temp;
	int		i;
	int		j;

	i = 0;
	while (i < n - 1)
	{
		j = 0;
		while (j < n - 1)
		{
			if (ft_strcmp(strings[i], strings[j]) < 0)
			{
				temp = strings[i];
				strings[i] = strings[j];
				strings[j] = temp;
			}
			j++;
		}
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_AST.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42madrid.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:47:41 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/19 19:44:34 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"

void	free_io_redir(t_io_redir *io_redir, int parent)
{
	t_io_redir	*tmp_io_redir;

	while (io_redir)
	{
		tmp_io_redir = io_redir->next;
		if (io_redir->hd_name && parent == 1)
			unlink(io_redir->hd_name);
		free(io_redir->hd_name);
		if (io_redir->filename)
		{
			free(io_redir->filename->text);
			free(io_redir->filename);
		}
		if (io_redir->op)
		{
			free(io_redir->op->text);
			free(io_redir->op);
		}
		free(io_redir);
		io_redir = tmp_io_redir;
	}
}

void	free_cmd(t_cmd *cmd, int parent)
{
	t_cmd	*tmp_cmd;
	char	**cmds_for_free;

	while (cmd)
	{
		free_io_redir(cmd->cmd_prefix, parent);
		free_io_redir(cmd->cmd_suffix, parent);
		cmds_for_free = (char **)cmd->cmd->darray;
		while (*cmds_for_free)
		{
			free(*cmds_for_free);
			cmds_for_free++;
		}
		free_darray(cmd->cmd);
		tmp_cmd = cmd->next;
		free(cmd);
		cmd = tmp_cmd;
	}
}

void	free_ast(t_cmd_pipe *sequence)
{
	t_cmd_pipe *tmp;

	while (sequence)
	{
		tmp = sequence->next;
		free_cmd(sequence->cmd, 1);
		free(sequence);
		sequence = tmp;
	}
}

// /* Nuevo helper: libera la tubería completa */
// void	free_cmd_pipe(t_cmd_pipe *pipe)
// {
// 	t_cmd_pipe	*next;

// 	while (pipe)
// 	{
// 		next = pipe->next;
// 		free_cmd(pipe->cmd);
// 		free(pipe);
// 		pipe = next;
// 	}
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_sig.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/16 17:31:13 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/18 16:13:11 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"

void	handle_sigint2(int sig)
{
	storage_signal(128 + sig, 1);
	write(1, "\n", 1);
	rl_on_new_line();
	rl_replace_line("", 0);
}

void	handle_sigquit2(int sig)
{
	storage_signal(128 + sig, 1);
}

void	handle_sigint_heredoc(int sig)
{
	storage_signal(128 + sig, 1);
	write(STDOUT_FILENO, "\n", 1);
	rl_on_new_line();
	rl_replace_line("", 0);
	close(0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42madrid.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:47:46 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/17 19:27:33y alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

// #include "parser.h"

// char	*get_hd_name(void)
// {
// 	char	*hd_name;
// 	char	*tmp;
// 	int		count_hd;

// 	count_hd = 0;
// 	tmp = NULL;
// 	hd_name = ft_strdup("./.heredoc");
// 	while (!access(hd_name, F_OK))
// 	{
// 		tmp = ft_itoa(count_hd);
// 		free(hd_name);
// 		hd_name = ft_strjoin("./.heredoc_", tmp);
// 		free(tmp);
// 		count_hd++;
// 	}
// 	return (hd_name);
// }

// void	process_heredoc_loop(int hdfd, char *delimiter, t_dictionary *env)
// {
// 	char	*next_line;
// 	char	*expanded_line;

// 	while (1)
// 	{
// 		next_line = readline("herdoc> ");
// 		if (storage_signal(0, 0))
// 			exit(130);
// 		if (!next_line)
// 			exit(0);
// 		if (ft_strcmp(next_line, delimiter) == 0)
// 		{
// 			free(next_line);
// 			break ;
// 		}
// 		expanded_line = expand_str(next_line, env);
// 		write(hdfd, expanded_line, ft_strlen(expanded_line));
// 		(write(hdfd, "\n", 1), free(next_line), free(expanded_line));
// 	}
// 	exit(0);
// }

// void	child_heredoc(t_io_redir *redir, t_token **stream, 
// 		char *delimiter, void *env)
// {
// 	int	hdfd;

// 	(void) stream;
// 	signal(SIGINT, handle_sigint_heredoc);
// 	signal(SIGQUIT, SIG_IGN);
// 	hdfd = open(redir->hd_name, O_RDWR | O_CREAT | O_TRUNC, 0644);
// 	if (hdfd == -1)
// 		exit(1);
// 	process_heredoc_loop(hdfd, delimiter, env);
// 	close(hdfd);
// 	exit(0);
// }

// int	here_doc(t_token **stream, t_io_redir *redir, t_dictionary *env)
// {
// 	pid_t	pid;
// 	int		status;

// 	redir->hd_name = get_hd_name();
// 	if (!redir->hd_name)
// 		return (1);
// 	pid = fork();
// 	if (pid < 0)
// 	{
// 		perror("fork");
// 		free(redir->hd_name);
// 		redir->hd_name = NULL;
// 		return (1);
// 	}
// 	if (pid == 0)
// 	{
// 		child_heredoc(redir, stream, redir->filename->text, env);
// 		free(redir->hd_name);
// 		exit(EXIT_SUCCESS);
// 	}
// 	signal(SIGINT, SIG_IGN);
// 	wait(&status);
// 	signal(SIGINT, handle_sigint2);
// 	signal(SIGQUIT, SIG_IGN);
// 	if (WIFSIGNALED(status) || WEXITSTATUS(status) != 0)
// 	{
// 		storage_signal(WEXITSTATUS(status), 1);
// 		free(redir->hd_name);
// 		redir->hd_name = NULL;
// 		return (WEXITSTATUS(status));
// 	}
// 	return (0);
// }

/* ───────────────────── heredoc_utils.c ───────────────────── */
#include "parser.h"
#include "../libft/include/get_next_line.h"
#include <signal.h>
#include <fcntl.h>

char	*get_hd_name(void)
{
	char	*hd_name;
	char	*tmp;
	int		count_hd;

	count_hd = 0;
	hd_name = ft_strdup("./.heredoc");
	while (!access(hd_name, F_OK))
	{
		tmp = ft_itoa(count_hd++);
		free(hd_name);
		hd_name = ft_strjoin("./.heredoc_", tmp);
		free(tmp);
	}
	return (hd_name);
}


/* ── 2.  Bucle con gnl ─────────────────────────────────────────── */
static int	process_heredoc_loop(int hdfd,
								char *delimiter,
								t_dictionary *env)
{
	char	*line;
	char	*expanded;

	while (1)
	{
		ft_printf("herdoc> ");                 /* prompt */
		line = get_next_line(STDIN_FILENO);
		// if (!line)                             /* EOF → fin heredoc           */
		// 	break ;
		if (storage_signal(0, 0))              /* ^C detectado                */
			return (free(line), -1);
		if (line[ft_strlen(line) - 1] == '\n')
			line[ft_strlen(line) - 1] = '\0';
		if (ft_strcmp(line, delimiter) == 0)
			return (free(line), 0);            // free str in gnl
		expanded = expand_str(line, env);
		write(hdfd, expanded, ft_strlen(expanded));
		write(hdfd, "\n", 1);
		free(line);
		free(expanded);
	}
	return (0);
}

// static int	process_heredoc_loop(int hdfd, char *delimiter, t_dictionary *env)
// {
// 	char	*line;
// 	char	*expanded;

// 	ft_printf("herdoc> ");
// 	while ((line = get_next_line(STDIN_FILENO)))
// 	{
// 		ft_printf("herdoc> ");                        
// 		if (line[ft_strlen(line) - 1] == '\n')
// 			line[ft_strlen(line) - 1] = '\0';
// 		if (storage_signal(0, 0))
// 			return (free(line), -1);
// 		if (ft_strcmp(line, delimiter) == 0)
// 			return (free(line), 0);
// 		expanded = expand_str(line, env);
// 		write(hdfd, expanded, ft_strlen(expanded));
// 		write(hdfd, "\n", 1);
// 		free(line);
// 		free(expanded);
// 	}
// 	return (0);
// }

int	here_doc(t_token **stream, t_io_redir *redir, t_dictionary *env)
{
	int		hdfd;
	int		ret;

	(void)stream;
	redir->hd_name = get_hd_name();
	if (!redir->hd_name)
		return (1);
	signal(SIGINT, handle_sigint_heredoc);
	signal(SIGQUIT, SIG_IGN);

	hdfd = open(redir->hd_name, O_RDWR | O_CREAT | O_TRUNC, 0644);
	if (hdfd == -1)
		return (free(redir->hd_name), redir->hd_name = NULL, 1);

	ret = process_heredoc_loop(hdfd, redir->filename->text, env);
	close(hdfd);
	signal(SIGINT, handle_sigint2);
	signal(SIGQUIT, SIG_IGN);

	if (ret == -1)
	{
		unlink(redir->hd_name);
		free(redir->hd_name);
		redir->hd_name = NULL;
		storage_signal(130, 1);
		return (1);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_command.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:48:17 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/18 16:19:18 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"

static int	alloc_cmd(t_cmd **ptr_cmd)
{
	*ptr_cmd = ft_calloc(1, sizeof(t_cmd));
	if (!(*ptr_cmd))
		return (0);
	(*ptr_cmd)->cmd = alloc_darray(2, sizeof(char *));
	if (!(*ptr_cmd)->cmd)
		return (free(*ptr_cmd), 0);
	return (1);
}

int	parse_ix(t_io_redir **ptr_io_redir, t_token **token_stream,
		t_dictionary *env)
{
	*ptr_io_redir = parse_io_redir(token_stream, env);
	if (!*ptr_io_redir)
		return (0);
	return (1);
}

int	fill_cmd(t_token **stream, t_command **ptr_cmd, t_dictionary *env)
{
	int	n_cmd;

	n_cmd = 0;
	while ((*stream)->type == COMMAND)
	{
		if (!add_command(ptr_cmd, ft_strdup((*stream)->text), env, n_cmd))
			return (0);
		(*stream)++;
		n_cmd++;
	}
	if (!add_command(ptr_cmd, NULL, env, n_cmd))
		return (0);
	return (1);
}

t_cmd	*init_cmd_parsing(t_token **token_stream)
{
	t_cmd	*ret_cmd;

	if ((*token_stream)->type == PIPE_OPERATOR)
	{
		ft_putstr_fd("minishell: syntax error near unexpected token `|'\n", 2);
		storage_signal(2, 1);
		return (NULL);
	}
	if (!alloc_cmd(&ret_cmd))
		return (NULL);
	return (ret_cmd);
}

t_cmd	*parse_cmd(t_token **token_stream, t_dictionary *env)
{
	t_cmd	*ret_cmd;
	t_cmd	*tmp_cmd;
	t_cmd	*current_cmd;

	ret_cmd = init_cmd_parsing(token_stream);
	current_cmd = ret_cmd;
	while ((*token_stream)->type != END
		&& (*token_stream)->type != PIPE_OPERATOR)
	{
		if (!parse_ix(&current_cmd->cmd_prefix, token_stream, env))
			return (free_cmd(ret_cmd, 1), NULL);
		if (!fill_cmd(token_stream, &current_cmd->cmd, env))
			return (free_cmd(ret_cmd, 1), NULL);
		if (!parse_ix(&current_cmd->cmd_suffix, token_stream, env))
			return (free_cmd(ret_cmd, 1), NULL);
		if (!alloc_cmd(&tmp_cmd))
			return (free_cmd(ret_cmd, 1), NULL);
		current_cmd->next = tmp_cmd;
		current_cmd = tmp_cmd;
	}
	current_cmd->next = NULL;
	return (ret_cmd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_io_redir.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42madrid.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:48:22 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/19 19:10:50 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"

int	alloc_io_redir(t_io_redir **ptr__io_redir)
{
	*ptr__io_redir = ft_calloc(1, sizeof(t_io_redir));
	if (!*ptr__io_redir)
		return (0);
	return (1);
}

t_io_redir	*parse_io_redir(t_token **token_stream, t_dictionary *env)
{
	t_io_redir	*ret_io_redir;
	t_io_redir	*current_io_redir;
	t_io_redir	*tmp_io_redir;

	current_io_redir = NULL;
	ret_io_redir = NULL;
	while ((*token_stream)->type == IO_OPERATOR)
	{
		if (!alloc_io_redir(&tmp_io_redir))
			return (free_io_redir(ret_io_redir, 1), NULL);
		if (!current_io_redir)
		{
			current_io_redir = tmp_io_redir;
			ret_io_redir = current_io_redir;
		}
		else
		{
			current_io_redir->next = tmp_io_redir;
			current_io_redir = tmp_io_redir;
		}
		current_io_redir->op = ft_calloc(1, sizeof(t_token));
		current_io_redir->op->text = ft_strdup((*token_stream)->text);
		(*token_stream)++;
		current_io_redir->filename = parse_word(token_stream);
		if (current_io_redir->filename && current_io_redir->filename->type != FILENAME)
		{
			ft_putstr_fd("minishell: syntax error near unexpected token ", 2);
			if ((*token_stream)->type == END)
				ft_putstr_fd("`newline'\n", 2);
			else
				ft_printf("%s\n", (*token_stream)->text);
			storage_signal(2, 1);
			return (free_io_redir(ret_io_redir, 1), NULL);
		}
		if (current_io_redir->filename && !ft_strcmp(current_io_redir->op->text, "<<"))
		{
			if (here_doc(token_stream, current_io_redir, env))
				return (free_io_redir(ret_io_redir, 1), NULL);
		}
	}
	if (!ret_io_redir)
		alloc_io_redir(&ret_io_redir);
	else
		alloc_io_redir(&current_io_redir->next);
	return (ret_io_redir);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_pipe.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42madrid.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:48:25 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/19 19:27:43 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"

int	is_empty_cmd(t_cmd *cmd)
{
	if (cmd->cmd_prefix->op->type != END
		&& cmd->cmd_prefix->filename->type != END)
		return (0);
	if (cmd->cmd->full_idx > 0)
		return (0);
	if (cmd->cmd_suffix->op->type != END
		&& cmd->cmd_suffix->filename->type != END)
		return (0);
	if (cmd->next)
		return (0);
	return (1);
}

int	alloc_pipe_cmd(t_cmd_pipe **ptr_cmd_pipe)
{
	*ptr_cmd_pipe = ft_calloc(1, sizeof(t_cmd_pipe));
	if (!(*ptr_cmd_pipe))
		return (0);
	return (1);
}

t_cmd_pipe	*parse_cmd_pipe(t_token **token_stream, t_dictionary *env)
{
	t_cmd_pipe	*ret_cmd_pipe;
	t_cmd_pipe	*current_cmd_pipe;
	t_cmd_pipe	*tmp_cmd_pipe;

	if (!*token_stream)
		return (NULL);
	if (!alloc_pipe_cmd(&ret_cmd_pipe))
		return (NULL);
	ret_cmd_pipe->cmd = parse_cmd(token_stream, env);
	if (!ret_cmd_pipe->cmd)
		return (NULL);
	current_cmd_pipe = ret_cmd_pipe;
	while ((*token_stream)->type == PIPE_OPERATOR)
	{
		(*token_stream)++;
		if (!alloc_pipe_cmd(&tmp_cmd_pipe))
			return (NULL);
		tmp_cmd_pipe->cmd = parse_cmd(token_stream, env);
		current_cmd_pipe->next = tmp_cmd_pipe;
		current_cmd_pipe = tmp_cmd_pipe;
		if (!tmp_cmd_pipe->cmd)
			return (NULL);
	}
	current_cmd_pipe->next = NULL;
	return (ret_cmd_pipe);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42madrid.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:48:27 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/19 19:05:06 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"

t_token	*parse_word(t_token **token_stream)
{
	t_token	*ret_token;

	if ((*token_stream)->type != FILENAME && (*token_stream)->type != END)
		return (NULL);
	ret_token = ft_calloc(1, sizeof(t_token));
	ret_token->text = ft_strdup((*token_stream)->text);
	ret_token->type = (*token_stream)->type;
	if ((*token_stream)->type != END)
		(*token_stream)++;
	return (ret_token);
}

int	handle_expansion(t_command **cmd, char *element, t_dictionary *env)
{
	char	**split;
	char	*expanded_cmd;
	char	*append_arg;
	int		i;

	expanded_cmd = expand_str(element, env);
	if (!expanded_cmd)
		return (0);
	split = ft_split(expanded_cmd, ' ');
	if (!split)
		return (free(expanded_cmd), 0);
	i = -1;
	while (split[++i])
	{
		append_arg = ft_strdup(split[i]);
		if (!append_darray(cmd, &append_arg))
			return (free(expanded_cmd), ft_free_array(split), 0);
	}
	(free(expanded_cmd), ft_free_array(split));
	return (1);
}

int	add_command(t_command **cmd, char *element, t_dictionary *env, int exp)
{
	(void)exp;
	if (!element || (element && element[0] != '$') || (element
			&& element[0] == '$' && exp))
	{
		if (!append_darray(cmd, &element))
			return (0);
		return (1);
	}
	return (handle_expansion(cmd, element, env));
}

void	print_from_diff(char *AST, char *expected)
{
	int	i;

	i = 0;
	while (AST[i] == expected[i] && AST[i] != '\0' && expected[i] != '\0')
		i++;
	ft_printf("A: %s\n", &AST[i]);
	ft_printf("e: %s\n", &expected[i]);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   print_AST.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42madrid.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:48:31 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/19 17:34:34 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"

void	print_io_redir(t_io_redir *io_redir, char ix_type)
{
	if (io_redir)
	{
		if (io_redir->op && io_redir->op->type != END)
			ft_printf("%c (%s ", ix_type, io_redir->op->text);
		if (io_redir->op && io_redir->filename->type != END)
			ft_printf("%s) ", io_redir->filename->text);
		print_io_redir(io_redir->next, ix_type);
	}
}

void	print_io_redirections(t_cmd *cmd)
{
	while (cmd)
	{
		print_io_redir(cmd->cmd_prefix, 'p');
		print_io_redir(cmd->cmd_suffix,'s');
		cmd = cmd->next;
	}
}

void	print_cmd(t_cmd *cmd)
{
	char		**command_list;
	t_command	*cmd_array;
	t_cmd		*tmp_cmd;
	size_t		i;

	print_io_redirections(cmd);
	ft_printf("{ ");
	tmp_cmd = cmd;
	while (tmp_cmd)
	{
		i = 0;
		cmd_array = tmp_cmd->cmd;
		command_list = (char **)cmd_array->darray;
		while (command_list && command_list[i])
		{
			ft_printf("%s ", command_list[i]);
			i++;
		}
		tmp_cmd = tmp_cmd->next;
	}
	ft_printf("} ");
}

void	print_ast(t_cmd_pipe *sequence)
{
	print_cmd(sequence->cmd);
	if (sequence->next)
	{
		ft_printf("| \n");
		print_ast(sequence->next);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   loop.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lalex-ku <lalex-ku@42sp.org.br>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/06/22 17:32:45 by lalex-ku          #+#    #+#             */
/*   Updated: 2022/06/22 17:32:50 by lalex-ku         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

int	main(int argc, char const *argv[])
{
	int	pid;

	pid = fork();
	open("infile", O_RDONLY);
	while (1)
	{
		printf("Helloo miniHELL %i\n", pid);
		sleep(1);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenizer2.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvmoral <alvmoral@student.42madrid.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/17 10:01:54 by lvez-dia          #+#    #+#             */
/*   Updated: 2025/05/19 19:16:11 by alvmoral         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "tokenizer.h"

int	process_tokenization(char *line, t_darray *tokens)
{
	int	i;
	int	start;

	i = 0;
	start = 0;
	while (tokens->full_idx < count_n_tokens(line))
	{
		while (still_in_quote(line[i], '\''))
			i++;
		while (still_in_quote(line[i], '\"'))
			i++;
		if (is_simple_operator(line[i]))
		{
			if (!tokenize_operator(line, &i, &start, &tokens))
				return (free(line), 0);
			continue ;
		}
		else if (isspace(line[i]) || !line[i])
		{
			if (!tokenize_literal(line, &i, &start, &tokens))
				return (free(line), 0);
		}
		i++;
	}
	add_token(&tokens, NULL);
	return (1);
}

t_darray	*tokenizer_str(char *line)
{
	char		*tmp_line;
	t_darray	*tokens;

	tmp_line = line;
	line = ft_strtrim(line, " ");
	if (!line)
		return (NULL);
	free(tmp_line);
	tokens = alloc_darray(count_n_tokens(line) + 1, sizeof(char *));
	if (!tokens)
		return (free(line), NULL);
	if (!process_tokenization(line, tokens))
		return (NULL);
	free(line);
	return (tokens);
}

t_token	*tokenizer_t_tokens(char **tokens_strings, size_t len)
{
	int		i;
	t_token	*token_stream;

	i = 0;
	token_stream = malloc((len + 1) * sizeof(t_token));
	if (!token_stream)
		return (free(token_stream), NULL);
	while (tokens_strings[i])
	{
		token_stream[i].text = ft_strdup(tokens_strings[i]);
		if (tokens_strings[i][0] == '|')
			token_stream[i].type = PIPE_OPERATOR;
		else if (is_double_operator(tokens_strings[i][0]))
			token_stream[i].type = IO_OPERATOR;
		else if (i > 0 && token_stream[i - 1].type == IO_OPERATOR)
			token_stream[i].type = FILENAME;
		else
			token_stream[i].type = COMMAND;
		i++;
	}
	token_stream[i].type = END;
	token_stream[i].text = NULL;
	return (token_stream);
}

/*t_token	*tokenizer_t_tokens(char **tokens_strings, size_t len)
{
	int			i;
	t_token		*token_stream;
	t_io_redir	*ret_io_redir;
	t_io_redir	*current_io_redir;
	t_io_redir	*tmp_io_redir;

	i = 0;
	token_stream = malloc((len + 1) * sizeof(t_token));
	i = 0;
	while (tokens_strings[i])
	{
		token_stream[i].text = handle_fin_quotes(tokens_strings[i],
				unclosed_quote_char(tokens_strings[i]));
		if (tokens_strings[i][0] == '|')
			token_stream[i].type = PIPE_OPERATOR;
		else if (is_double_operator(tokens_strings[i][0]))
			token_st
	}
t_io_redir	*parse_io_redir(t_token * *token_stream, t_dictionary * env)
	{
		if (!alloc_io_redir(&ret_io_redir))
			return (NULL);
		current_io_redir = ret_io_redir;
		while ((*token_stream)->type == IO_OPERATOR)
		{
			current_io_redir->op = (*token_stream);
			(*token_stream)++;
			current_io_redir->filename = parse_word(token_stream);
			if (current_io_redir->filename == NULL
				|| current_io_redir->filename->type != FILENAME)
			{
				ft_putstr_fd("minishell: syntax error near unexpected token ",
					2);
				if ((*token_stream)->type == END)
					ft_putstr_fd("`newline'\n", 2);
				else
					ft_printf("%s\n", (*token_stream)->text);
				storage_signal(2, 1);
				return (free_io_redir(ret_io_redir), NULL);
			}
			if (!ft_strcmp(current_io_redir->op->text, "<<"))
			{
				if (here_doc(current_io_redir->filename->text, current_io_redir,
						env))
					return (free_io_redir(ret_io_redir), NULL);
			}
			if (!alloc_io_redir(&tmp_io_redir))
				return (free_io_redir(ret_io_redir), NULL);
			current_io_redir->next = tmp_io_redir;
			current_io_redir = tmp_io_redir;
		}
		current_io_redir->next = NULL;
		ream[i].type = IO_OPERATOR;
		else if (i > 0 && token_stream[i
				- 1].type == IO_OPERATOR) token_stream[i].type = FILENAME;
		else token_stream[i].type = COMMAND;
		i++;
	}
	token_stream[i].type = END;
	token_stream[i].text = NULL;
	return (token_stream);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenizer.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:50:25 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/19 13:46:19 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "tokenizer.h"

void	process_operator(char *argv, int *i, size_t *n_op)
{
	if (*i && !isspace(argv[*i - 1]) && !is_simple_operator(argv[*i - 1]))
		(*n_op)++;
	if (argv[*i] == argv[*i + 1])
		(*i)++;
	(*n_op)++;
	while (isspace(argv[*i + 1]))
		(*i)++;
}

void	process_whitespace(char *argv, int *i, size_t *n_op)
{
	while (isspace(argv[*i]))
		(*i)++;
	if (argv[*i] != '\0')
		(*n_op)++;
	(*i)--;
}

size_t	count_n_tokens(char *argv)
{
	int		i;
	size_t	n_op;

	i = 0;
	n_op = 0;
	while (argv[i])
	{
		while (still_in_quote(argv[i], '\''))
			i++;
		while (still_in_quote(argv[i], '"'))
			i++;
		if (is_simple_operator(argv[i]))
			process_operator(argv, &i, &n_op);
		else if (isspace(argv[i]))
			process_whitespace(argv, &i, &n_op);
		if (argv[i])
			i++;
	}
	if (i > 0 && !is_double_operator(argv[i - 1]))
		++n_op;
	return (n_op);
}

int	tokenize_operator(char *line, int *i, int *start, t_darray **tokens)
{
	int	len_op;

	len_op = 1;
	if (*i != 0 && !isspace(line[*i - 1]) && !is_simple_operator(line[*i - 1]))
	{
		if (!add_token(tokens, ft_substr(line, *start, *i - *start)))
			return (free_darray(*tokens), 0);
	}
	if (line[*i] == line[*i + 1])
		len_op++;
	if (!add_token(tokens, ft_substr(line, *i, len_op)))
		return (free_darray(*tokens), 0);
	if (line[*i] == line[*i + 1])
		*i = *i + 1;
	while (isspace(line[*i + 1]) && line[*i + 1] != '\0')
		*i = *i + 1;
	*i = *i + 1;
	*start = *i;
	return (1);
}

int	tokenize_literal(char *line, int *i, int *start, t_darray **tokens)
{
	if (!add_token(tokens, ft_substr(line, *start, *i - *start)))
		return (free_darray(*tokens), 0);
	while (isspace(line[*i]))
		*i = *i + 1;
	*start = *i;
	*i = *i - 1;
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenizer_quotes.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:51:57 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/18 16:06:38 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "tokenizer.h"

char	*handle_fin_quotes(char *line, char quote)
{
	t_darray	*darr;
	char		*tmp;
	char		*quote_line;
	int			i;

	if (quote == '\0')
		return (ft_strdup(line));
	quote_line = NULL;
	darr = alloc_darray(10, sizeof(char));
	append_darray(&darr, "\n");
	while (1)
	{
		while(!quote_line)
			quote_line = readline("quote> ");
		i = 0;
		while (quote_line[i])
			append_darray(&darr, &quote_line[i++]);
		append_darray(&darr, "\n");
		if (ft_strchr(quote_line, quote))
			break ;
		free(quote_line);
		quote_line = NULL;
	}
	tmp = ft_strjoin(line, (char *)darr->darray);
	return (free(quote_line), free_darray(darr), tmp);
}

void	process_quotes(const char *str, bool *in_single_quote,
		bool *in_double_quote)
{
	int	i;

	i = 0;
	while (str[i] != '\0')
	{
		if (str[i] == '\\')
		{
			if (str[i + 1] != '\0')
			{
				i += 2;
				continue ;
			}
		}
		else if (str[i] == '\'' && !(*in_double_quote))
			*in_single_quote = !(*in_single_quote);
		else if (str[i] == '"' && !(*in_single_quote))
			*in_double_quote = !(*in_double_quote);
		i++;
	}
}

char	unclosed_quote_char(const char *str)
{
	bool	in_single_quote;
	bool	in_double_quote;

	in_single_quote = false;
	in_double_quote = false;
	process_quotes(str, &in_single_quote, &in_double_quote);
	if (in_single_quote)
		return ('\'');
	if (in_double_quote)
		return ('"');
	return ('\0');
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenizer_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alvaro <alvaro@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 17:50:22 by alvmoral          #+#    #+#             */
/*   Updated: 2025/05/19 13:45:36 by alvaro           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "tokenizer.h"

int	is_simple_operator(char argv_char)
{
	if (argv_char == '>')
		return (1);
	else if (argv_char == '<')
		return (1);
	else if (argv_char == '|')
		return (1);
	else
		return (0);
}

int	is_double_operator(char argv_char)
{
	if (argv_char == '>')
		return (1);
	else if (argv_char == '<')
		return (1);
	else
		return (0);
}

int	still_in_quote(char c, char quote)
{
	static int	inside_quote = 0;

	if (c == quote)
	{
		inside_quote = 1 - inside_quote;
		if (!inside_quote)
			return (0);
		return (1);
	}
	if (c == '\0')
		inside_quote = 0;
	if (inside_quote == 1)
		return (1);
	else
		return (0);
}

int	add_token(t_darray **tokens, char *element)
{
	if (!append_darray(tokens, &element))
		return (0);
	return (1);
}

void	free_tokens(t_token *tokens)
{
	int	i;

	i = 0;
	if (!tokens)
		return ;
	while (tokens[i].type != END)
	{
		free(tokens[i].text);
		i++;
	}
	free(tokens);
}
